#!/usr/bin/env python

from __future__ import print_function
# Should make it "backwards" compatible down to 2.6

# This small utility can save a scipy sparse
# matrix in a NetCDF-4 file readable by tbtrans
# and hence you can gain access to a transport code
# without having to code the essentials.
# However, this also means that you do need
# to follow some strict rules.
# In the following several classes are made available
# to ease the creation of TB models for TBtrans.

# class TBT_TB
#   this class handles the saving of the TB model.
#   It requires a geometry formatted as TBT_Geom
#   and two csr-formatted sparse matrices (H and S)
#   Call the function .save(fname)
#   to save a NetCDF-4 file readable by tbtrans.

# class TBT_Geom
#   Handles geometries and is a quite powerful geometry
#   handler.
#   It enables a user to construct repeated cells for
#   tbtrans.
#   Specifically it allows one to easily find the 
#   neighbours of certain atoms by this easy call:
#     idx = TBT_Geom.close_all(ia,(1.,2.,3.))
#   which returns 3 index arrays (len(idx) == 3) which specifies:
#     idx[0] : all atoms within <= 1. of atom ia
#     idx[1] : all atoms within <= 2. of atom ia, but farther
#              away than 1. (1. < xa[:,:] - xa[ia,:][None,:] <= 2.)
#     idx[2] : all atoms within <= 3. of atom ia, but farther
#              away than 2. (2. < xa[:,:] - xa[ia,:][None,:] <= 3.)
#   With this call it is extremely easy to get nearest neighbours
#   etc. from a simple geometry.
#   You can repeat or tile the structure by these calls:
#     new_Geom = TBT_Geom.tile(3,0).tile(2,2)
#   which takes the geometry and repeats the entire structure
#   3 times in the x-direction, then those repeated cells
#   2 times in the z-direction. (thus the total size will be
#   3*2 * TBT_Geom.na_u
#     TBT_Geom.repeat()
#   works in the same way but enables one to utilize
#   Bloch enabled electrodes.
#   You can also remove certain atoms from the structure,
#   just do:
#     new_Geom = TBT_Geom.remove(np.arange(3))
#   which removes the first 3 atoms.
#
#   NOTE: The geometry class expects coordinates in Ang.

# The difficult class
# class TB_Model
#   This class solely handles the assignment of TB parameters
#   for the model.
#   To create a model simply pass a TBT_Geom to the initialization.
#   and the object will be setup correspondingly.
#     model = TBT_Model(TBT_Geom())
#   The only thing you need to do now is assigning 
#   TB parameters to the model.
#     model[i,j] = (H,S) [ H should be in eV ]
#   will create a hopping integral between orbital i and j
#   As the model can use periodicity you also need to
#   create the supercell interactions (it will not do this
#   for you)
#   An easy way is to ask for which sets you should set is
#   to use the geometry object to retrieve the closest
#   atoms and from there create your orbitals.
#   This is extremely easy for single orbital atoms
#   whereas for N orbital atoms this is a little bit more
#   tricky.
#   See the below code for how to construct a TB model for
#   graphene.
#

# PLEASE
# !!!
# Do not edit this file without contributing 
# your edits to the community!
# What is helping you, could MOST likely also
# help others in the community!
# Respect the maintainer, the code and the other users.
# !!!

# Written by: Nick Papior Andersen, 2014

# Load needed modules
import copy, os, datetime
import itertools as it, warnings
import numpy as np
try:
    import netCDF4 as nc
except:
    # Fake an object to always throw errors if called
    # The user can still use this module without netCDF4py installed
    class nc(object):
        def __getitem__(self,key):
            raise Exception('netCDF4 could not be imported. Please install to take full advantage.')
        __getattr__ = __getitem__

# Check for file-existance
def _file_exist(fname):
    """ Returns true if file exists """
    return os.path.isfile(fname)

class SIESTA_UNITS(object):
    """
    Object to retain all SIESTA relevant units
    """
    # constant fields for converting Ry/Bohr to eV/Ang
    # SIESTA/tbtrans requires Ry and Bohr
    Ry = 13.60580
    Bohr = 0.529177


class TBT_Geom(SIESTA_UNITS):
    """
    Geometry object handling atomic coordinates in a supercell
    much like that of SIESTA.
    
    This geometry class is however not restricted to SIESTA as it 
    is a general class to retain coordinates and the cell structure.
    
    All lengths are assumed to be in units of Angstrom.
    
    Parameters
    ----------
    cell  : array_like
        cell vectors in a 3x3 matrix.
        ``cell[i,:]`` is the cell vector along the i'th direction.
    xa    : array_like
        atomic coordinates in a Nx3 matrix.
        ``xa[i,:]`` is the atomic coordinate of the i'th atom.
        This atomic coordinate need not be inside the unit-cell.
    dR    : (2.5) float, optional
        The geometry's maximum orbital range. All orbitals are 
        assumed localised on the atomic centers. 
    n_orb : (1) integer/array_like, optional
        Number of orbitals per atom. If a single integer
        is supplied all atoms have the same number of orbitals,
        whereas providing a array will set the number of orbitals
        individually.
        NOTE that if you have a consistent alternation you can
        do with the smallest repetition of the array.
    Z     : (1) array_like and/or integer/string, optional
        atomic number or name of the atoms in the geometry. 
        Defaults to Hydrogen.
        Examples:
          >>> ``Z = 'Carbon'`` # makes all atoms Carbon atoms.
          >>> ``Z = ['Carbon','H']`` # alternates between C and H atoms, for all len(xa) % 2 == 0.

    update_sc : (False), boolean, optional
        If ``False`` it will initialise size of the super-cell to
        be one connection in all directions.
        If ``True`` it will calculate the super-cell size based
        on ``dR``.

    Attributes
    ----------
    cell : (3,3) ndarray
        Cell vectors.
    na_u : integer
        Number of atoms.
    xa   : (na_u,3) ndarray
        Atomic coordinates.
    lasto: (na_u+1) 
        Last orbital of the equivalent atom (this is offset by one)
        Hence ``lasto[0]`` is always ``0`` and ``lasto[1]`` is the
        number of orbitals on the first atom.
    no_u : integer
        Total number of orbitals 
    dR   : float
        Maximum orbital range.
    Z    : (na_u)
        Atomic number of atom.
    iter : 15, integer
        When using the geometry as an iterator this defines the bunches
        of data that will be used to reduce the search space.
        The smaller the number the more often the iterator will search the entire
        space for close atoms. The sub-space searched will then be small.
        For a larger number it well search less often but in a larger sub-space.
        The optimium depends on number of atoms within the sphere `dR * iter`
        As a rule-of-thumb `dR * iter` should contain ~500-1000 atoms to be efficient.
    """
    def __init__(self,cell,xa,dR=2.5,n_orb=1,Z=1,update_sc=False,iter=15):
        self.cell = np.asarray(cell)
        self.xa = np.asarray(xa)
        self.xa.shape = (-1,3)
        self.na_u = len(xa)
        self.Z = np.zeros((self.na_u,),np.int)
        # Convert to integers
        ptbl = PeriodicTable()
        if isinstance(Z,(list,np.ndarray)):
            Z = self._repeat(Z,self.na_u)
        self.Z[:] = ptbl.Z(Z)
        del ptbl # clean-up
        if isinstance(n_orb,(int,np.int,np.int16,np.int32)):
            # We have a fixed number of orbitals per
            # atom
            self.lasto = np.arange(self.na_u+1) * n_orb
        else:
            n_orb = self._repeat(n_orb,self.na_u)
            # The user have specified number of orbitals
            # per atom, explicitly
            self.lasto = np.cumsum(
                np.append(np.array(0,np.int),np.asarray(n_orb,np.int)))
        self.no_u = int(self.lasto[-1])
        self.dR = dR

        # Force the calculation of the super-cells from an orbital
        # range consideration
        if update_sc: 
            self.update(dR=dR)
        else:
            # We force any TB method to be periodic
            # with one supercell connection.
            # Hence any reference will copy this down
            self.update(nsc=[1,1,1])

        # This defines the amount of dR that will be used in each iterator step
        self._iter = iter

    def __repr__(self):
        """ Representation of the object """
        spec = self._species_order()
        s = 'Atoms {0}\nOrbitals {1}\nDifferent species {2}\n'.format(self.na_u,self.no_u,len(spec))
        s += 'Species:\n'
        ptbl = PeriodicTable()
        for z in spec:
            s += '  {0}\n'.format(ptbl.Z_short(z))
        s += 'Supercells {0}, {1}, {2}\n'.format(*(self.nsc // 2))
        s += 'Maximum interaction range {0}'.format(self.dR)
        return s

    def __len__(self):
        """ Returns number of atoms in this geometry """
        return self.na_u

    def __iter__(self):
        """ 
        Returns two lists with [0] being a list of atoms to be looped and [1] being the atoms that 
        need searched.

        NOTE: This requires that dR has been set correctly as the maximum interaction range.

        I.e. the loop would look like this:
        
        >>> for ias, idxs in TBT_Geom:
        >>>    for ia in ias:
        >>>        idx_a = dev.close_all(ia, dR = dR, idx = idxs)

        This iterator is intended for systems with more than 1000 atoms.

        Remark that the iterator used is non-deterministic, i.e. any two iterators need
        not return the same atoms in any way.
        """

        # We implement yields as we can then do nested iterators
        # create a boolean array
        not_passed = np.empty(len(self),dtype='b')
        not_passed[:] = True
        not_passed_N = len(self)

        # The boundaries (ensure complete overlap)
        dR = ( self.dR * (self._iter - 1), self.dR * (self._iter+.1))

        # loop until all passed are true
        while not_passed_N > 0:
            
            # Take a random non-passed element
            all_true = np.where(not_passed)[0]
            # Shuffle should increase the chance of hitting a
            # completely "fresh" segment, thus we take the most 
            # atoms at any single time.
            # Shuffling will cut down needed iterations.
            np.random.shuffle(all_true)
            idx = all_true[0]
            del all_true

            # Now we have found a new index, from which
            # we want to create the index based stuff on
            
            # get all elements within two radii
            all_idx = self.close_all(idx, dR = dR )

            # Get unit-cell atoms
            all_idx[0] = self.sc2uc(all_idx[0])
            # First extend the search-space (before reducing)
            all_idx[1] = self.sc2uc(np.append(all_idx[1],all_idx[0]))

            # Only select those who have not been runned yet
            all_idx[0] = all_idx[0][np.where(not_passed[all_idx[0]])[0]]
            if len(all_idx[0]) == 0:
                raise ValueError('Internal error, please report to the developers')

            # Tell the next loop to skip those passed
            not_passed[all_idx[0]] = False
            # Update looped variables
            not_passed_N -= len(all_idx[0])

            # Now we want to yield the stuff revealed
            # all_idx[0] contains the elements that should be looped
            # all_idx[1] contains the indices that can be searched
            yield all_idx[0], all_idx[1]

        if np.any(not_passed):
            raise ValueError('Error on iterations. Not all atoms has been visited.')

    @staticmethod
    def _repeat(array,size):
        """
        This repeats an array along the zeroth axis until it
        has size `size`. Note that initial size of `array` has
        to be an integer part of `size`.
        """
        reps = size // len(array)
        if size % len(array) != 0:
            # We do not have it correctly formatted (either an integer
            # repeatable part, full, or a single)
            raise ValueError('Repetition of or array is not divisible with actual length. ' +
                             'Hence we cannot create a repeated size.')
        if reps > 1: return np.tile(array,reps)
        return array

    @classmethod
    def SIESTA(cls,fname):
        """Creates a geometry from a SIESTA.nc file

        Parameters
        ----------
        fname : (string)
            A NetCDF filename from which the geometry will be read in.
            It will read in the``xa``, ``cell``, ``lasto`` and ``nsc``
            variables and return a geometry from those quantities.
        """
        nf = nc.Dataset(fname,'r')
        xa = np.asarray(nf.variables['xa'][:]) * TBT_Geom.Bohr
        cell  = np.asarray(nf.variables['cell'][:]) * TBT_Geom.Bohr
        lasto = np.asarray(nf.variables['lasto'][:],np.int)
        nsc   = np.asarray(nf.variables['nsc'][:],np.int) // 2
        Z = None
        if 'BASIS' in nf.groups:
            bg = nf.groups['BASIS']
            b_idx = np.array(bg.variables['basis'][:],np.int)
            # Loop all basis-sets and get the atomic number
            n_b = len(bg.groups)
            zb = np.zeros((n_b,),np.int)
            for basis in bg.groups:
                ID = bg.groups[basis].ID
                bZ = bg.groups[basis].Atomic_number
                zb[ID-1] = int(bZ)
            Z = zb[b_idx - 1]
        nf.close()
        n_orb = np.diff(lasto)
        n_orb = np.append(lasto[0],n_orb)
        # Create new geometry
        g = cls(cell=cell,xa=xa,n_orb=n_orb,Z=Z)
        g.update(nsc=nsc)
        return g

    @property
    def n_orb(self):
        """ Returns number of orbitals for the equivalent atom """
        return np.diff(self.lasto)

    def __init_new(self,cell,xa,n_orb,Z=None,update_sc=False):
        """
        Internal routine to easily handle initialization
        of a new geometry, however if the user
        requests update_sc = False
        we copy the nsc and isc_off from the local 
        copy.
        """
        g = self.__class__(cell,xa,dR=self.dR,
                           n_orb=n_orb,Z=Z,
                           update_sc=update_sc,iter=self._iter)
        if not update_sc:
            g.nsc = np.copy(self.nsc)
            g.isc_off = np.copy(self.isc_off)
        return g

    @property
    def no_s(self):
        """ Number of supercell orbitals """
        return self.no_u * np.prod(self.nsc)

    def sub(self,atoms,cell=None,update_sc=False):
        """
        Returns a subset of atoms from the geometry.

        Indices passed *MUST* be unique.

        Parameters
        ----------
        atoms  : array_like
            indices of all atoms to be removed.
        cell   : (``self.cell`), array_like, optional
            the new associated cell of the geometry
        update_sc : (False), boolean, optional
            Whether the super-cell size should be recalculated using
            ``self.dR``.
        """
        if cell is None: cell = self.cell
        return self.__init_new(cell,self.xa[atoms,:], 
                               n_orb = np.diff(self.lasto)[atoms],
                               Z = self.Z[atoms])

    def cut(self,axis,seps=2):
        """
        Returns a subset of atoms from the geometry by cutting the 
        geometry into ``seps`` parts along the direction ``axis``.
        It will then _only_ return the first cut.
        
        This will effectively change the unit-cell in the ``axis`` as-well
        as removing ``self.na_u/seps`` atoms.
        It requires that ``self.na_u % seps == 0``.

        REMARK: You need to ensure that all atoms within the first 
        cut out region are within the primary unit-cell.

        Doing ``geom.cut(1).tile(2,axis=1)``, could for symmetric setups,
        be equivalent to a no-op operation. A `UserWarning` will be issued
        if this is not the case.

        Parameters
        ----------
        axis  : integer
           the axis that will be cut
        seps  : (2), integer, optional
           number of times the structure will be cut.
        """
        if self.na_u % seps != 0:
            raise ValueError('The system cannot be cut into {0} different '+
                             'pieces. Please check your geometry and input.'.format(seps))
        # Cut down cell
        cell = np.copy(self.cell)
        cell[axis,:] /= seps
        new = self.sub(np.arange(self.na_u//seps),cell=cell)
        if not np.allclose(new.tile(seps,axis=axis).xa,self.xa):
            warnings.warn('The cut structure cannot be re-created by tiling', UserWarning) 
        return new

    def update(self,dR=None,nsc=None,iter=None):
        """ Updates the internals of the geometry 

        Mostly used for updating number of supercells.

        Parameters
        ----------
        dR   : (None), float
            If provided the super-cell will be calculating based on the
            atomic coordinates and the maximum orbital range.
        nsc  : (None), array_like
            If provided the super-cell will be forced to this size,
            providing ``[1,1,1]`` tells the geometry that
            interactions are connecting across one cell boundary.
        iter : (None), integer
            Changes the number of steps used when iterating

        If no parameters are given ``self.update()`` will
        use the saved ``self.dR`` size (as given when initialised).
        """
        if not iter is None:
            self._iter = iter
            if dR is None and nsc is None: return
        if dR is None:
            # Just update the super-cell, this is
            # if the user has changed the cell size
            ddR = self.dR
        else:
            self.dR = dR
            ddR = dR
        if not nsc is None:
            # The user put in the super-cell
            self.nsc = np.copy(nsc) * 2 + 1
        else:
            nsc = np.zeros([3],np.int)
            # loop over x-y-z directions
            for d in [0,1,2]:
                # create diagonal offset
                sc = np.zeros([3],np.int)
                # We need only check in the positive direction 
                # after all, it is periodic
                i = 0
                while True:
                    i += 1
                    sc[d] = i
                    for ia in xrange(self.na_u):
                        if len(self.close_sc(ia,isc=sc,dR=ddR)) > 0:
                            nsc[d] = i
                            break
                    # No interactions to auxiliary cell,
                    # so break the search
                    if nsc[d] < i: break
            # We have now calculated the required size
            # Re-set the nsc and the supercell indices
            # (correct for super-cells)
            self.nsc = nsc * 2 + 1

        # This variable determines the supercell
        self.isc_off = np.zeros([np.prod(self.nsc),3],np.int)

        # We define the following ones like this:
        x = range(-nsc[0],nsc[0]+1)
        y = range(-nsc[1],nsc[1]+1)
        z = range(-nsc[2],nsc[2]+1)
        i = 0
        for iz in z:
            for iy in y:
                for ix in x:
                    if ix == 0 and iy == 0 and iz == 0:
                        continue
                    # Increment index
                    i += 1
                    # The offsets for the supercells in the
                    # sparsity pattern
                    self.isc_off[i,0] = ix
                    self.isc_off[i,1] = iy
                    self.isc_off[i,2] = iz
    # compatibility
    update_sc = update

    def _species_order(self):
        """ Returns dictionary with species indices for the atoms.
        They will be populated in order of appearence"""

        # Count for the species
        spec = {}
        ispec = 0
        for ia in xrange(self.na_u):
            if self.Z[ia] in spec:
                sp = spec[self.Z[ia]]
            else:
                ispec += 1
                spec[self.Z[ia]] = ispec
                sp = ispec
        return spec

    @classmethod
    def read(cls,fname):
        """ Reads a structure from an arbitrary input file """
        if fname[-3:].upper() == '.XV':
            return cls.read_XV(fname)
        elif fname[-3:].lower() == '.nc':
            return cls.SIESTA(fname)
        raise NotImplementedError('Reading file: '+fname+' have not been implemented yet.')

    @classmethod
    def read_XV(cls,fname):
        """
        Reads a structure from an XV file
        """
        cell = np.empty([3,3],np.float)
        with open(fname,'r') as fh:
            for i in range(3):
                cell[i,:] = np.fromstring(fh.readline(), dtype=float, sep = ' ')[0:3]
            cell *= cls.Bohr
            # Read number of atoms
            na_u = int(fh.readline())
            Z = np.empty(na_u,np.int)
            xa = np.empty([na_u,3],np.float)
            line = np.empty(8,np.float)
            for i in xrange(na_u):
                line[:] = np.fromstring(fh.readline(),dtype=float,sep = ' ')[0:8]
                Z[i] = int(line[1])
                xa[i,:] = line[2:5]
            xa *= cls.Bohr
            return cls(cell=cell,xa=xa,n_orb=1,Z=Z)

    def xyz(self,fname=None,fmt='.5f',overwrite=False):
        """
        Creates an xyz file for showing in visual programs
        
        Parameters
        ----------
        fname : str 
            Filename to save the xyz format in.
        fmt   : (.5f) str
            Format for the output file
        overwrite:
            Whether one should overwrite the file if it already exists
        """
        if _file_exist(fname) and not overwrite:
            raise Exception('File: '+fname+' already exists, we do not allow overwriting, please remove file manually.')

        if fname:
            ptbl = PeriodicTable()
            with open(fname,'w') as fh:
                fh.write(str(self.na_u)+'\n\n')
                fm = (' {:'+fmt+'}') * 3 + '\n'
                for ia in xrange(self.na_u):
                    fh.write(ptbl.Z_short(self.Z[ia])+fm.format(*self.xa[ia,:]))
                fh.write('\n')

    def XV(self,fname=None,overwrite=False):
        """
        Creates an XV file for compatibility with SIESTA

        Note the velocity will always be set to 0.
        
        Parameters
        ----------
        fname : str 
            Filename to save the XV format in.
        overwrite:
            Whether one should overwrite the file if it already exists
        """
        if _file_exist(fname) and not overwrite:
            raise Exception('File: '+fname+' already exists, we do not allow overwriting, please remove file manually.')

        if fname:
            with open(fname,'w') as fh:
                # Write unit-cell
                tmp = np.zeros(6,np.float)
                for i in range(3):
                    tmp[0:3] = self.cell[i,:] / self.Bohr
                    l = (('   ' + '{:18.9f}'*3)*2).format(*tmp)
                    fh.write(l + '\n')
                fh.write('{:12d}\n'.format(self.na_u))
                # Get species order
                spec = self._species_order()
                fmt  = '{:3d}{:6d}'
                fmt += '{:18.9f}'*3 + '   ' + '{:18.9f}'*3
                fmt += '\n'
                for ia in xrange(self.na_u):
                    tmp[0:3] = self.xa[ia,:] / self.Bohr
                    Z = self.Z[ia]
                    sp = spec[Z]
                    fh.write(fmt.format(sp,Z,*tmp))

    def fdf(self,fname=None,fmt='.5f',overwrite=False):
        """
        Creates an fdf file for SIESTA
        
        Parameters
        ----------
        fname : str 
            Filename to save the FDF format in.
        fmt   : (.5f) str
            Format for the output file
        overwrite:
            Whether one should overwrite the file if it already exists
        """
        if _file_exist(fname) and not overwrite:
            raise Exception('File: '+fname+' already exists, we do not allow overwriting, please remove file manually.')

        if fname:
            ptbl = PeriodicTable()
            with open(fname,'w') as fh:
                # Write out the cell
                fh.write('LatticeConstant 1. Ang\n')
                fh.write('%block LatticeVectors\n')
                for i in range(3):
                    fh.write(' {0} {1} {2}\n'.format(*self.cell[i,:]))
                fh.write('%endblock LatticeVectors\n\n')
                fh.write('NumberOfAtoms {0}\n'.format(self.na_u))
                fh.write('AtomicCoordinatesFormat Ang\n')
                fh.write('%block AtomicCoordinatesAndAtomicSpecies\n')

                fmt_str = ' {{2:{0}}} {{3:{0}}} {{4:{0}}} {{0}} # {{1}}\n'.format(fmt)
                # Count for the species
                spec = self._species_order()
                for ia in xrange(self.na_u):
                    sp = spec[self.Z[ia]]
                    fh.write(fmt_str.format(sp,ia+1,*self.xa[ia,:]))
                fh.write('%endblock AtomicCoordinatesAndAtomicSpecies\n\n')

                # Write out species
                # First swap key and value
                spec = dict(zip(spec.values(), spec.keys()))
                ispec = len(spec)
                fh.write('NumberOfSpecies {0}\n'.format(ispec))
                fh.write('%block ChemicalSpeciesLabel\n')
                for i in range(ispec):
                    fh.write(' {0} {1} {2}\n'.format(i+1,spec[i+1],ptbl.Z_short(spec[i+1])))
                fh.write('%endblock ChemicalSpeciesLabel\n')

    def copy(self):
        """
        Returns a copy of the object.
        """
        # Create a copy of this geometry
        return self.__init_new(np.copy(self.cell),np.copy(self.xa),
                               n_orb=np.diff(self.lasto),Z=np.copy(self.Z))

    def remove(self,atoms,update_sc=False):
        """
        Remove atoms from the geometry.

        Indices passed *MUST* be unique.

        Parameters
        ----------
        atoms  : array_like
            indices of all atoms to be removed.
        update_sc : (False), boolean, optional
            Whether the super-cell size should be recalculated using
            ``self.dR``.
        """
        # truncate atoms requested
        idx = np.setdiff1d(np.arange(self.na_u),atoms,assume_unique=True)
        return self.sub(idx,update_sc=update_sc)

    def tile(self,reps,axis,update_sc=False):
        """ 
        Returns a geometry tiled, i.e. copied.

        The atomic indices are retained for the base structure.

        Parameters
        ----------
        reps  : number of tiles (repetitions)
        axis  : direction of tiling 
                  0, 1, 2 according to the cell-direction
        update_sc : (False), boolean, optional

        Examples
        --------
        >>> geom = TBT_Geom(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xa=[[0,0,0],[0.5,0,0]])
        >>> g = geom.tile(2,0)
        >>> print(g.xa)
        [[ 0.   0.   0. ]
         [ 0.5  0.   0. ]
         [ 1.   0.   0. ]
         [ 1.5  0.   0. ]]
        >>> g = geom.tile(2,0).tile(2,1)
        >>> print(g.xa)
        [[ 0.   0.   0. ]
         [ 0.5  0.   0. ]
         [ 1.   0.   0. ]
         [ 1.5  0.   0. ]
         [ 0.   1.   0. ]
         [ 0.5  1.   0. ]
         [ 1.   1.   0. ]
         [ 1.5  1.   0. ]]

        """
        cell = np.copy(self.cell)
        cell[axis,:] *= reps
        # Pre-allocate geometry
        # Our first repetition *must* be with
        # the later coordinate
        # Copy the entire structure
        xa = np.tile(self.xa,(reps,1))
        Z = np.tile(self.Z,reps)
        orbs = np.tile(np.diff(self.lasto),reps)
        # Single cell displacements
        dx = np.dot(np.arange(reps)[:,None],self.cell[axis,:][None,:])
        # Correct the unit-cell offsets
        xa[0:self.na_u*reps,:] += np.repeat(dx,self.na_u,axis=0)
        # Create the geometry and return it
        return self.__init_new(cell,xa,n_orb=orbs,Z=Z,update_sc=update_sc)

    def repeat(self,reps,axis,update_sc=False):
        """
        Returns a geometry repeated, i.e. copied in a special way.

        The atomic indices are *NOT* retained for the base structure.

        The expansion of the atoms are basically performed using this
        algorithm:
          ja = 0
          for ia in range(self.na_u):
              for id,r in args:
                 for i in range(r):
                    ja = ia + cell[id,:] * i

        This method allows to utilise Bloch's theorem when creating
        tight-binding parameter sets for TBtrans.

        For geometries with a single atom this routine returns the same as
        ``self.tile``.

        It is adviced to only use this for electrode Bloch's theorem
        purposes as ``self.tile`` is faster.
        
        Parameters
        ----------
        reps  : number of repetitions
        axis  : direction of repetition
                  0, 1, 2 according to the cell-direction
        update_sc : (False), boolean, optional

        Examples
        --------
        >>> geom = TBT_Geom(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xa=[[0,0,0],[0.5,0,0]])
        >>> g = geom.repeat(2,0)
        >>> print(g.xa)
        [[ 0.   0.   0. ]
         [ 1.   0.   0. ]
         [ 0.5  0.   0. ]
         [ 1.5  0.   0. ]]
        >>> g = geom.repeat(2,0).repeat(2,1)
        >>> print(g.xa)
        [[ 0.   0.   0. ]
         [ 1.   0.   0. ]
         [ 0.   1.   0. ]
         [ 1.   1.   0. ]
         [ 0.5  0.   0. ]
         [ 1.5  0.   0. ]
         [ 0.5  1.   0. ]
         [ 1.5  1.   0. ]]

        """
        # Figure out the size
        cell = np.copy(self.cell)
        cell[axis,:] *= reps
        # Pre-allocate geometry
        new_na_u = self.na_u * reps
        xa = np.zeros([new_na_u,3],np.float)
        Z = np.zeros(new_na_u,np.float)
        n_orb = np.diff(self.lasto)
        orbs = np.zeros(new_na_u,np.int)
        dx = np.dot(np.arange(reps)[:,None],self.cell[axis,:][None,:])
        # Start the repetition
        ja = 0
        for ia in xrange(self.na_u):
            # Single atom displacements
            # First add the basic atomic coordinate,
            # then add displacement for each repetition.
            xa[ja:ja+reps,:] = self.xa[ia,:][None,:] + dx[:,:]
            Z[ja:ja+reps] = self.Z[ia]
            orbs[ja:ja+reps] = n_orb[ia]
            ja += reps
        # Create the geometry and return it
        return self.__init_new(cell,xa,n_orb=orbs,Z=Z,update_sc=update_sc)

    def append(self,other,axis,update_sc=False):
        """
        Appends structure along ``axis``. This will automatically
        add the ``self.cell[axis,:]`` to all atomic coordiates in the 
        ``other`` structure before appending.

        The basic algorithm is this:
        
          >>> oxa = other.xa + self.cell[axis,:][None,:]
          >>> self.xa = np.append(self.xa,oxa)
          >>> self.cell[axis,:] += other.cell[axis,:]
          >>> self.lasto = np.append(self.lasto,other.lasto)

        NOTE: The cell appended is only in the axis that
        is appended, which means that the other cell directions
        need not conform.

        Parameters
        ----------
        other : TBT_Geom
            Other geometry class which needs to be appended
        axis  : int
            Cell direction to which the ``other`` geometry should be
            appended.
        update_sc : (False), boolean, optional
            Whether the super-cell size should be re-calculated.

        """
        xa = np.append(self.xa,
                       self.cell[axis,:][None,:] + other.xa,
                       axis=0)
        Z = np.append(self.Z,other.Z)
        cell = np.copy(self.cell)
        cell[axis,:] += other.cell[axis,:]
        orbs = np.append(np.diff(self.lasto),np.diff(other.lasto))
        return self.__init_new(cell,xa,n_orb=orbs,Z=Z,update_sc=update_sc)

    def a2o(self,ia):
        """
        Returns an orbital index of the first orbital of said atom.
        This is particularly handy if you want to create
        TB models with more than one orbital per atom.

        Then assigning TB parameters look something like:
        (here shown for two orbitals per atom)
        
        Parameters
        ----------
        ia : list,int
             Atomic indices

        Examples
        --------

        >>> # Only nearest neighbour interactions
        >>> dR = (.1, 2.)
        >>> for ia in xrange(self.na_u):
        >>>     io = self.a2o(ia)
        >>>     idx_a = HUGE.close_all(ia,dR=dR)
        >>>     # first orbital on-site
        >>>     HS[io+0,self.a2o(idx_a[0])+0] = (U1 ,   1. )
        >>>     # second orbital on-site
        >>>     HS[io+1,self.a2o(idx_a[0])+1] = (U2 ,   1. )
        >>>     # orbital hopping to same orbital
        >>>     HS[io+0,self.a2o(idx_a[1])+0] = (t11,   0. )
        >>>     HS[io+1,self.a2o(idx_a[1])+1] = (t22,   0. )
        >>>     # orbital hopping to differing orbital
        >>>     HS[io+0,self.a2o(idx_a[1])+1] = (t12,   0. )
        >>>     HS[io+1,self.a2o(idx_a[1])+0] = (t12,   0. )

        """
        return self.lasto[ia % self.na_u] + (ia // self.na_u) * self.no_u

    def o2a(self,io):
        """
        Returns an atomic index corresponding to the orbital indicies.

        This is not particurlaly fast.

        Parameters
        ----------
        io: list,int
             List of indices to return the atoms for
        """
        rlasto = self.lasto[::-1]
        iio = np.asarray([io % self.no_u]).flatten()
        a = [self.na_u - np.argmax(rlasto <= i) for i in iio]
        return np.asarray(a) + ( io // self.no_u ) * self.na_u

    def sc2uc(self,atoms):
        """ Returns atoms from super-cell indices to unit-cell indices (removing dublicates) """
        return np.unique(atoms % self.na_u)

    def coords(self,isc=[0,0,0],idx=None):
        """
        Returns the coordinates of a given super-cell.

        Parameters
        ----------
        isc   : array_like
            Returns the atomic coordinates shifted according to the integer
            parts of the cell.
        idx   : int/array_like
            Only return the coordinates of these indices

        Examples
        --------
        
        >>> geom = TBT_Geom(cell=[[1.,0,0],[0,1.,0.],[0,0,1.]],xa=[[0,0,0],[0.5,0,0]])
        >>> print(geom.coords(isc=[1,0,0])
        [[ 1.   0.   0. ]
         [ 1.5  0.   0. ]]

        """
        offset = self.cell[0,:] * isc[0] + \
            self.cell[1,:] * isc[1] + \
            self.cell[2,:] * isc[2]
        if idx is None:
            return self.xa + offset[None,:]
        else:
            return self.xa[idx,:] + offset[None,:]

    def sc_idx(self,isc):
        """
        Returns the geometry index for the supercell
        corresponding to isc ([ix,iy,iz])
        """
        asc = np.asarray(isc,np.int)
        for i in xrange(self.isc_off.shape[0]):
            if np.all(self.isc_off[i,:] == asc): return i
        raise Exception('Could not find supercell index')

    def a2isc(self,a):
        """
        Returns the super-cell index for a specific atom

        Hence one can easily figure out the supercell
        """
        idx = np.where( a < self.na_u * np.arange(1,np.product(self.nsc)+1) )[0][0]
        return self.isc_off[idx,:]

    def o2isc(self,o):
        """
        Returns the super-cell index for a specific orbital.

        Hence one can easily figure out the supercell
        """
        idx = np.where( o < self.no_u * np.arange(1,np.product(self.nsc)+1) )[0][0]
        return self.isc_off[idx,:]

    def close_sc(self,xyz_ia,isc=[0,0,0],dR=None,idx=None,ret_coord=False):
        """
        Calculates which atoms are close to some atom or point
        in space, only returns so relative to a super-cell.

        This returns a set of atomic indices which are within a 
        sphere of radius ``dR``.

        If dR is a tuple/list/array it will return the indices:
        in the ranges:
           ( x <= dR[0] , dR[0] < x <= dR[1], dR[1] < x <= dR[2] )

        Parameters
        ----------
        xyz_ia    : coordinate/index
            Either a point in space or an index of an atom.
            If an index is passed it is the equivalent of passing
            the atomic coordinate ``self.close_sc(self.xa[xyz_ia,:])``.
        isc       : ([0,0,0]), array_like, optional
            The super-cell which the coordinates are checked in.
        dR        : (None), float/tuple of float
            The radii parameter to where the atomic connections are found.
            If ``dR`` is an array it will return the indices:
            in the ranges:
               ``( x <= dR[0] , dR[0] < x <= dR[1], dR[1] < x <= dR[2] )``
            If a single float it will return:
               ``x <= dR``
        idx       : (None), array_like
            List of atoms that will be considered. This can
            be used to only take out a certain atoms.
        ret_coord : (False), boolean
            If true this method will return the coordinates 
            for each of the couplings.
        """

        if dR is None:
            ddR = np.array([self.dR],np.float)
        else:
            ddR = np.array([dR],np.float).flatten()
        ioff = 0
        if isinstance(xyz_ia,(int,np.int,np.int16,np.int32)):
            off = self.xa[xyz_ia,:]
            # Get atomic coordinate in principal cell
            dxa = self.coords(isc=isc,idx=idx) - off[None,:]
        else:
            off = xyz_ia
            # The user has passed a coordinate
            dxa = self.coords(isc=isc,idx=idx) - off[None,:]

        # Retrieve all atomic indices which are closer
        # than our delta-R
        # The linear algebra norm function could be used, but it
        # has a lot of checks, hence we do it manually
        #xaR = np.linalg.norm(dxa,axis=-1)
        xaR = (dxa[:,0]**2+dxa[:,1]**2+dxa[:,2]**2) ** .5
        ix = np.where(xaR <= ddR[-1])[0]
        if ret_coord:
            xa = dxa[ix,:] + off[None,:]
        del dxa # just because these arrays could be very big...
        if len(ddR) == 1:
            # We only have one designation
            if idx is None:
                if ret_coord:
                    return ix + ioff, xa
                return ix + ioff
            else:
                if ret_coord:
                    return idx[ix], xa
                return idx[ix]
        if np.any(np.diff(ddR) < 0.):
            raise ValueError('Proximity checks for several quantities '+ \
                                 'at a time requires ascending dR values.')

        # Reduce search space!
        # The more neigbours you wish to find the faster this becomes
        # We only do "one" heavy duty search,
        # then we immediately reduce search space to this subspace
        xaR = xaR[ix]
        ix[:] += ioff
        tidx = np.where(xaR <= ddR[0])[0]
        if ret_coord:
            xx = [xa[tidx]]
        if idx is None:
            x = [ix[tidx]]
        else:
            x = [idx[ix[tidx]]]
        for i in range(1,len(ddR)):
            # Search in the sub-space
            # Notice that this sub-space reduction will never
            # allow the same indice to be in two ranges (due to
            # numerics)
            tidx = np.where(np.logical_and(ddR[i-1] < xaR,xaR <= ddR[i]))[0]
            if ret_coord: xx.append(xa[tidx])
            if idx is None:
                x.append(ix[tidx])
            else:
                x.append(idx[ix[tidx]])
        if ret_coord: return x,xx
        return x

    def close_all(self,xyz_ia,dR=None,idx=None,ret_coord=False):
        """
        Returns supercell atomic indices for all atoms connecting to ``xyz_ia``

        This heavily relies on the ``self.close_sc`` method.

        Note that if a connection is made in a neighbouring super-cell
        then the atomic index is shifted by the super-cell index times
        number of atoms.
        This allows one to decipher super-cell atoms from unit-cell atoms.

        Parameters
        ----------
        xyz_ia  : coordinate/index
            Either a point in space or an index of an atom.
            If an index is passed it is the equivalent of passing
            the atomic coordinate ``self.close_sc(self.xa[xyz_ia,:])``.
        dR      : (None), float/tuple of float
            The radii parameter to where the atomic connections are found.
            If ``dR`` is an array it will return the indices:
            in the ranges:
               ``( x <= dR[0] , dR[0] < x <= dR[1], dR[1] < x <= dR[2] )``
            If a single float it will return:
               ``x <= dR``
        idx     : (None), array_like
            List of indices for atoms that are to be considered
        ret_coord : (False), boolean
            If true this method will return the coordinates 
            for each of the couplings.
        """

        idx_a = None
        xa = None
        for s in xrange(np.prod(self.nsc)):
            na = s * self.na_u
            if ret_coord:
                ix, xx = self.close_sc(xyz_ia,self.isc_off[s,:],dR=dR,idx=idx,ret_coord=True)
            else:
                ix = self.close_sc(xyz_ia,self.isc_off[s,:],dR=dR,idx=idx)
            if isinstance(ix,list):
                # we have a list of arrays
                if idx_a is None:
                    idx_a = [x + na for x in ix]
                    if ret_coord: 
                        xa = xx
                else:
                    for i,x in enumerate(ix):
                        idx_a[i] = np.append(idx_a[i],x + na)
                        if ret_coord: 
                            xa[i] = np.append(xa[i],xx[i])
                            xa[i].shape = (-1,3)
            elif len(ix) > 0:
                # We can add it to the list
                # We add the atomic offset for the supercell 
                # index
                if idx_a is None:
                    idx_a = ix + na
                    if ret_coord: 
                        xa = xx
                else:
                    idx_a = np.append(idx_a,ix + na)
                    if ret_coord: 
                        xa = np.append(xa,xx)
                        xa.shape = (-1,3)
        if ret_coord: return idx_a,xa
        return idx_a
        

class TBT_Model(SIESTA_UNITS):

    _GEOM = TBT_Geom
    """
    Tight binding model handler to create a Hamiltonian
    for arbitrary systems.

    This heavily relies on the ``TBT_Geom`` class which initializes the
    system size.

    Parameters
    ----------
    geom            : TBT_Geom
        The geometry that determines the tight-binding model to be
        created.
        From the geometry the number of orbitals etc. will be 
        initialized.
    max_connection  : (None), integer, optional
        Sets the maximum number of connections for all atoms for the
        pre-allocated sparsity pattern.

        When ``None`` it will calculate the maxmimum number of
        connections based on ``geom.dR`` and the interactions
        in the cell.

        For large systems calculating the mamximum number
        of connections can take a lot of time.
        You are encouraged to set this to some number, it only has effect
        on the memory used for the basic sparsity pattern.

        You can safely set this to a safely high number.

    Attributes
    ----------
    geom : TBT_Geom
        Class object which is the same as the passed geometry
    max_n: integer
        Maximum number of orbital connections, when creating
        the sparsity pattern the pre-allocated Hamiltonian has
        size ``max_n*self.geom.no_u``.
    ncol : (no_u) ndarray
        Number of connections for the i'th orbital.
    ptr  : (no_u+1) ndarray
        Pointer to the sparsity pattern where the i'th orbital indices
        starts.
    col  : (nnzs) ndarray
        Column indices for the sparsity pattern:
           >>> col[ptr[i]+0]
        is the first matrix element that corresponds to the Hamiltonian
        element ``H[i,col[ptr[i]+0]]``
        Hence all connections to the i'th orbital can be found using this
        loop:
           >>> for j in range(ncol[i]):
           >>>    H[i,col[ptr[i]+j] ...
    HS   : (nnzs,2) ndarray
        The Hamiltonian ([:,0]) and the overlap ([:,1]) matrix in sparse
        format.
        The full Hamiltonian can be created using ``ptr`` and ``col``.
        It is saved in CSR format.
        Note that the sparsity format is a non-square matrix, but rather
        a matrix with ``self.geom.no_u`` rows and ``self.geom.no_u*np.prod(self.geom.nsc)`` columns.
    nnzs : integer
        Number of non-zero elements in the sparsity pattern.

    """
    def __init__(self,geom,max_connection=None):
        self.geom = geom
        # We first find the maximal number of connections per atom
        max_n = 0
        if max_connection:
            max_n = max_connection
        else:
            # Determine maximum number of connections explicitly
            for ia in xrange(geom.na_u):
                idx = geom.close_all(ia)
                max_n = max(max_n,len(idx))

        self.max_n = max_n
        self.reset()

    def __len__(self):
        """ Returns number of interactions in this model """
        return self.nnzs

    def __repr__(self):
        """ Representation of the object """
        s = self.geom.__repr__()
        s += '\nNumber of non-zero elements {0}'.format(self.nnzs)
        return s

    @property
    def no_u(self):
        """ Returns the number of orbitals for the geometry """
        return self.geom.no_u

    @property
    def no_s(self):
        """ Returns number of orbitals in the super-cell """
        return self.geom.no_s

    @property
    def na_u(self):
        """ Returns the number of atoms for the geometry """
        return self.geom.na_u

    def sub(self,atoms,cell=None):
        """ 
        Creates a sub-set of the current model from the input
        geometry.

        Parameters
        ----------
        atoms  : array_like
           the atoms that will be used to create a new structure.
        cell  : (None), array_like, optional
           if provided this will be the new cell for the geometry
        """
        # Reduce the sparsity pattern
        raise NotImplementedError('Taking sub partitions of TB-models '+
                                  'have not been implemented, see cut.')

    def cut(self,axis,seps=2):
        """ 
        Cuts the tight-binding model into different parts.

        Creates a tight-binding model by retaining the parameters
        for the cut-out region.

        Parameters
        ----------
        axis  : integer
           the axis that will be cut
        seps  : (2), integer, optional
           number of times the structure will be cut.
        """
        # Create new geometry
        with warnings.catch_warnings(record=True) as w:
            # Cause all warnings to always be triggered.
            warnings.simplefilter("always")
            geom = self.geom.cut(axis,seps)
            # Check whether the warning exists
            if len(w) > 0:
                if issubclass(w[-1].category,UserWarning):
                    raise ValueError('You cannot cut a tight-binding model '+
                                     'if the structure cannot be recreated using tiling constructs.')
        
        # Now we need to re-create the tight-binding model
        H, S = self.tocsr()
        # they are created similarly, hence the following
        # should keep their order

        # First we need to figure out how long the interaction range is
        # in the cut-direction
        # We initialize to be the same as the parent direction
        nsc = self.geom.nsc // 2
        nsc[axis] = 0 # we count it
        isc = np.zeros((3,),np.int)
        isc[axis] -= 1
        out = False
        while not out:
            # Get supercell index
            isc[axis] += 1
            try:
                idx = self.geom.sc_idx(isc)
            except: break
            # Figure out how long it interacts
            sub = H[0:geom.no_u,idx*self.no_u:(idx+1)*self.no_u].indices[:]
            if len(sub) == 0: break
            c_max = np.amax(sub)
            # Count the number of cells it interacts with
            i = (c_max % self.no_u) // geom.no_u
            ic = idx * self.no_u
            for j in range(i):
                idx = ic + geom.no_u * j
                # We need to ensure that every "in between" index exists
                # if it does not we discard those indices
                if len(np.where( 
                        np.logical_and(idx <= sub, 
                                       sub < idx + geom.no_u)
                        )[0]) == 0:
                    i = j - 1
                    out = True
                    break
            nsc[axis] = isc[axis] * seps + i
            
            if out:
                warnings.warn('Cut the connection at {0} in direction {1}.'.format(nsc[axis],axis), UserWarning) 

            
        # Update number of super-cells
        geom.update(nsc=nsc)

        # Now we have a correct geometry, and 
        # we are now ready to create the sparsity pattern
        # Reduce the sparsity pattern, first create the new one
        tb = self.__class__(geom,max_connection=self.max_n)

        def sco2sco(M,o,m,axis,seps):
            # Converts an o from M to m
            isc = np.copy( M.o2isc(o) )
            isc[axis] *= seps
            # Count cell-offset
            i = (o % M.no_u) // m.no_u
            isc[axis] += i
            # find the equivalent cell in m
            try:
                # If a fail happens it is due to a discarded
                # interaction across a non-interacting region
                return ( o % m.no_u, 
                        m.sc_idx( isc) * m.no_u, 
                        m.sc_idx(-isc) * m.no_u)
            except:
                return None, None, None

        # Copy elements
        for jo in xrange(geom.no_u):

            # make smaller cut
            sH = H[jo,:]
            sS = S[jo,:]

            for io, iH, iS in zip(sH.indices,sH.data,sS.data):
                # Get the equivalent orbital in the smaller cell
                o, ofp, ofm = sco2sco(self.geom,io,tb.geom,axis,seps)
                if o is None: continue
                tb[jo,o+ofp] = iH, iS
                tb[o,jo+ofm] = iH, iS

        return tb

    def _reset_sp(self):
        """ Reset the sparsity pattern """
        # To increase performance of creating
        # the TB parameters we fix the connections
        # per orbital to the maximum number of
        # connections, then later we truncate
        # Hence our ncol keeps track of how many we actually have
        self.ncol = np.zeros((self.geom.no_u,),np.int)
        self.ptr = np.cumsum(np.repeat(np.array([self.max_n],np.int),
                             self.geom.no_u+1)) - self.max_n
        self._nnzs = 0
        self.col = np.empty((self.ptr[-1],),np.int)

        self._finalized = False

    def reset(self,dtype=np.float):
        """
        The sparsity pattern is cleaned and every thing 
        is reset. 

        The object will be the same as if it had been
        initialized with the same geometry as it were
        created with.
        """
        # I know that this is not the most efficient way to
        # access a C-array, however, for constructing a
        # sparse pattern, it should be faster if memory elements
        # are closer... 
        # Hence, this choice of having H and S like this

        self._reset_sp()
        # Initialize HS size
        self.HS = np.empty((self.ptr[-1],2),dtype=dtype)

    def finalize(self):
        """ 
        Finalizes the object so that no new sparse elements
        can be added. 

        Sparse elements can still be changed.
        """
        if self._finalized: return
        self._finalized = True
        ptr = self.ncol[0]
        if np.unique(self.col[:ptr]).shape[0] != ptr:
            raise ValueError('You cannot have two hoppings between '+
                             'the same orbitals.')
        if self.geom.no_u > 1:
            # We truncate all the connections
            for io in xrange(1,self.geom.no_u):
                cptr = self.ptr[io]
                # Update actual pointer position
                self.ptr[io] = ptr
                no = self.ncol[io]
                if no == 0: continue
                self.col[ptr:ptr+no]  = self.col[cptr:cptr+no]
                self.HS[ptr:ptr+no,:] = self.HS[cptr:cptr+no,:]
                # we also assert no two connections
                if np.unique(self.col[ptr:ptr+no]).shape[0] != no:
                    raise ValueError('You cannot have two hoppings between '+
                                     'the same orbitals.')
                ptr += no
        # Correcting the size of the pointer array
        self.ptr[self.geom.no_u] = ptr
        if ptr != self._nnzs:
            raise ValueError('Error in creating the TB parameter space')
        # Truncate values to correct size
        self.HS = self.HS[:self._nnzs,:]
        self.col = self.col[:self._nnzs]
        # Deleting the variable
        # will error out in _setitem when
        # it is referenced :)
        del self._nnzs

        # Sort the indices (THIS IS A REQUIREMENT!)
        for io in xrange(self.geom.no_u):
            ptr = self.ptr[io]
            no  = self.ncol[io]
            if no == 0: continue
            # Sort the indices
            si = np.argsort(self.col[ptr:ptr+no])
            self.col[ptr:ptr+no]  = self.col[ptr+si]
            self.HS[ptr:ptr+no,:] = self.HS[ptr+si,:]

    def __getitem__(self,key):
        """
        Returns the value of the index.

        Currently this does not work for slices.
        """
        i, j = key
        ind = np.where(self.col[self.ptr[i]:self.ptr[i]+self.ncol[i]] == j)[0]
        if len(ind) > 0:
            return self.HS[self.ptr[i]+ind[0],:]
        else:
            return 0., 0.

    def __setitem__(self,key,val):
        """
        Override set item for slicing operations and enables easy setting of TB parameters
        in a sparse matrix

        It does allow fancy slicing in both dimensions with limited usability
        
        Ok, it is not pretty, it is not fast, but it works!
        """
        # unpack index
        i , j = key
        if not isinstance(i,(int,np.int,np.int16,np.int32)):
            # Recursively handle index,index = val
            # designators.
            if len(i) > 1: 
                if len(i) != len(j):
                    raise ValueError('Size of LHS and RHS are not equal, error on input [LHS,RHS]')
                for ii,jj in zip(i,j):
                    self[int(ii),jj] = val
                return
            i = int(i[0])
        # step pointer of all above this
        ptr  = self.ptr[i]
        ncol = self.ncol[i]
        jj = np.asarray([j]).flatten()
        lj = jj.shape[0]
        if ncol > 0:
            # Checks whether any values in either array exists
            idx = np.intersect1d(jj,self.col[ptr:ptr+ncol],assume_unique=True)
        else:
            idx = []
        if len(idx) != 0:
            
            # Here we truncate jj to the "new" values,
            # this allows us to both overwrite and add new values to the sparsity pattern
            # (simultaneously)
            jj = np.setdiff1d(jj, idx, assume_unique=True)
            lj = jj.shape[0]

            # the values corresponding to idx already exists, we overwrite that value
            if isinstance(j,(int,np.int,np.int16,np.int32)):
                ix = ptr + np.where(j == self.col[ptr:ptr+ncol])[0][0]
                self.HS[ix,:] = val
            else:
                # remember that idx is the intersection values
                for ij in idx:
                    ix = ptr + np.where(ij == self.col[ptr:ptr+ncol])[0][0]
                    self.HS[ix,:] = val

            # if no new values are left we return immediately
            if lj == 0: return

        # As nnzs is deleted when the object has been finalized 
        # this line should error out.
        if self.col.shape[0] < self._nnzs + lj:
            print('Shape. col '+str(self.col.shape[0]) + ' and non-zero elements '+str(self._nnzs))
            raise ValueError('Have you changed the sparsity pattern while editing '+
                             'the TB parameters? This is not allowed.\n'+
                             'Or maybe you have initialized max_connection too small, try increasing it.')
        # Step to the placement of the new values
        ptr += ncol
        # set current value
        self.col[ptr:ptr+lj]  = jj
        self.HS[ptr:ptr+lj,:] = val
        self.ncol[i] += lj
        # Increment number of non-zero elements
        self._nnzs += lj

    @property
    def nnzs(self):
        """
        Returns number of current non-zero elements.
        """
        return np.sum(self.ncol)

    def tocsr(self,k=None):
        """
        Returns a CSR sparse matrix for both the Hamiltonian
        and the overlap matrix using the scipy package.
        
        This method depends on scipy.
        """
        self.finalize()

        # Create csr sparse formats.
        # We import here as the user might not want to
        # rely on this feature.
        from scipy.sparse import csr_matrix
        if k is None:
            shape = (self.no_u,self.no_u*np.product(self.geom.nsc))
            if self.HS.shape[1] == 1:
                return csr_matrix((self.HS[:,0],self.col,self.ptr),shape=shape)
            return (csr_matrix((self.HS[:,0],self.col,self.ptr),shape=shape), \
                        csr_matrix((self.HS[:,1],self.col,self.ptr),shape=shape))
        else:
            import scipy.linalg as sla
            # Setup the Hamiltonian for this k-point
            shape = (self.no_u,self.no_u*np.product(self.geom.nsc))
            Hfull = csr_matrix((self.HS[:,0],self.col,self.ptr),shape=shape)
            Sfull = csr_matrix((self.HS[:,1],self.col,self.ptr),shape=shape)
            shape = (self.no_u,self.no_u)
            H = csr_matrix(shape)
            S = csr_matrix(shape)
            # Get the reciprocal lattice vectors dotted with k
            rcell = sla.inv(self.geom.cell.copy())
            kr = np.dot(np.asarray(k),rcell) * np.pi * 2.
            for si in range(np.product(self.geom.nsc)):
                isc = self.geom.isc_off[si,:]
                phase = np.exp(1j*np.dot(kr,np.dot(self.geom.cell,isc)))
                H += Hfull[:,si*self.no_u:(si+1)*self.no_u] * phase
                S += Sfull[:,si*self.no_u:(si+1)*self.no_u] * phase
            del Hfull, Sfull
            return H,S

    def _save_sparsity(self,nf,zlib=0):
        """
        Saves the sparsity format if it does not currently exist
        in the file/group.
        Else it will check that the quantitites are the same.
        """
        self.finalize()

        cmp_lvl = zlib
        z_lib = zlib > 0

        if 'n_col' in nf.variables:
            # Check that the sparsity is the same
            if np.any(nf.variables['n_col'][:] != self.ncol):
                raise ValueError('The sparsity pattern is not the same')
            if np.any(nf.variables['list_col'][:] != self.col + 1):
                raise ValueError('The sparsity pattern is not the same')
        else:
            # Create the sparsity pattern
            if not 'nnzs' in nf.dimensions:
                nf.createDimension('nnzs',self.col.shape[0])
            
            v = nf.createVariable('n_col','i4',('no_u',))
            v.info = "Number of non-zero elements per row"
            v[:] = self.ncol
            v = nf.createVariable('list_col','i4',('nnzs',),
                                  zlib=z_lib,complevel=cmp_lvl,
                                  chunksizes=(len(self.col),))
            
            v.info = "Supercell column indices in the sparse format"
            v[:] = self.col[:] + 1

    @classmethod
    def SIESTA(cls,fname='SIESTA.nc',ispin=0):
        """
        Reads in a model from a SIESTA.nc file and enables 
        one to alter the Hamiltonian elements.
        """
        
        # First read the geometry
        geom = cls._GEOM.SIESTA(fname)

        # We overwrite the elements for the sparsity pattern
        # so no need to create it any bigger than it is
        model = cls(geom,max_connection=1)

        nf = nc.Dataset(fname,'r')
        sg = nf.groups['SPARSE']

        geom.isc_off = np.asarray(nf.groups['SPARSE'].variables['isc_off'][:],np.int)
        geom.nsc = np.amax(geom.isc_off,axis=0) * 2 + 1
        
        # Use Ef to move H to Ef = 0
        Ef = float(nf.variables['Ef'][0]) * cls.Ry
        S = np.array(sg.variables['S'][:],np.float)
        H = np.array(sg.variables['H'][ispin,:],np.float) * cls.Ry
        # Correct for the Fermi-level 
        # In that way Ef == 0
        H -= Ef * S[:]
        ncol = np.array(sg.variables['n_col'][:],np.int)
        # Update maximum number of connections (in case future stuff happens)
        model.max_n = np.amax(ncol)
        ptr = np.append(np.array(0,np.int),np.cumsum(ncol))
        # Ensure that it is flattened
        ptr.shape = (-1,)
        col = np.array(sg.variables['list_col'][:],np.int) - 1
        # Copy information over
        model.ncol = ncol
        model.ptr = ptr
        model.col = col
        model._nnzs = len(col)
        # Create new container
        model.HS = np.empty((model.nnzs,2),np.float)
        model.HS[:,0] = H[:]
        model.HS[:,1] = S[:]

        # One thing missing is the distance of interactions
        # dR, here we calculate this quantity
        dR = 0.
        for ia in xrange(len(geom)):
            # Loop over all atoms
            # Gather all orbitals
            o = geom.a2o(ia)
            orbs = np.copy(col[ptr[o]:ptr[o]+ncol[o]])
            # Loop all other orbitals
            for io in range(o+1,o+ncol[o]):
                orbs = np.append(orbs,col[ptr[o]:ptr[o]+ncol[o]])
            orbs = np.unique(orbs)
            # Get the atoms in the supercell
            atoms = geom.o2a(orbs)
            del orbs
            # Loop on all atoms to find the distance between them
            for ja in atoms:
                isc = geom.a2isc(ja)
                R = geom.coords(isc=isc,idx=geom.sc2uc(ja)) - geom.coords(idx=ia)
                R.shape = (3,)
                dR = max(dR,(R[0]**2+R[1]**2+R[2]**2)**.5)

        # Update dR (add 0.1 AA) and the super-cells
        dR = dR + 0.1
        model.geom.dR = dR

        return model

    def save(self,fname='SIESTA.nc',Ef=0.,zlib=0,overwrite=False):
        """
        Saves the current sparse Hamiltonian and overlap to a 
        NetCDF file which is readable by TBtrans.

        This routine will implicitly call ``self.finalize()``.

        Parameters
        ----------
        fname : (SIESTA.nc) str
            Filename to save the sparse information in.
        Ef    : (0. eV) float
            Fermi-level for the Hamiltonian
        zlib  : (0) integer
            Compression level of sparse elements, in range [0;9]
        """
        if os.path.isfile(fname) and not overwrite:
            raise Exception('File: '+fname+' already exists, we do not allow overwriting, please remove file manually.')

        # No need to finalize if exception cast
        self.finalize()

        nf = nc.Dataset(fname,'w',format='NETCDF4')

        cmp_lvl = zlib
        z_lib = zlib > 0

        # Create initial dimensions
        nf.createDimension('one',1)
        nf.createDimension('n_s',np.prod(self.geom.nsc))
        nf.createDimension('xyz',3)
        nf.createDimension('no_s',np.prod(self.geom.nsc)*self.geom.no_u)
        nf.createDimension('no_u',self.geom.no_u)
        nf.createDimension('spin',1)
        nf.createDimension('na_u',self.geom.na_u)

        # Create common variables
        v = nf.createVariable('nsc','i4',('xyz',))
        v.info = 'Number of supercells in each unit-cell direction'
        v = nf.createVariable('lasto','i4',('na_u',))
        v.info = 'Last orbital of equivalent atom'
        v = nf.createVariable('Ef','f8',('one',))
        v.info = 'Fermi level'
        v.unit = 'Ry'
        v = nf.createVariable('Qtot','f8',('one',))
        v.info = 'Total charge'
        v = nf.createVariable('xa','f8',('na_u','xyz'))
        v.info = 'Atomic coordinates'
        v.unit = 'Bohr'
        v = nf.createVariable('cell','f8',('xyz','xyz'))
        v.info = 'Unit cell'
        v.unit = 'Bohr'

        # Create attribute
        nf.method = 'python'

        sp = nf.createGroup('SPARSE')
        self._save_sparsity(sp,zlib=zlib)

        #sp.createDimension('nnzs',H.getnnz())
        v = sp.createVariable('isc_off','i4',('n_s','xyz'))
        v.info = "Index of supercell coordinates"
        v = sp.createVariable('S','f8',('nnzs',),
                              zlib=z_lib,complevel=cmp_lvl,
                              chunksizes=(len(self.col),))
        v.info = "Overlap matrix"
        v = sp.createVariable('H','f8',('spin','nnzs'),
                              zlib=z_lib,complevel=cmp_lvl,
                              chunksizes=(1,len(self.col)))
        v.info = "Hamiltonian"
        v.unit = "Ry"

        # We need to fake some BZ sampling... 
        # This will probably force the
        # user to utilize the check-kgrid F
        # in the electrodes.... well....
        st = nf.createGroup('SETTINGS')
        v = st.createVariable('ElectronicTemperature','f8',('one',))
        v.info = "Electronic temperature used for smearing DOS"
        v.unit = "Ry"
        v = st.createVariable('BZ','i4',('xyz','xyz'))
        v.info = "Grid used for the Brillouin zone integration"
        v = st.createVariable('BZ_displ','i4',('xyz',))
        v.info = "Monkhorst-Pack k-grid displacements"
        v.unit = "b**-1"

        # Save quantities
        nf.variables['nsc'][:] = self.geom.nsc
        nf.variables['lasto'][:] = self.geom.lasto[1:]
        nf.variables['Ef'][:] = Ef / self.Ry
        nf.variables['Qtot'][:] = self.geom.no_u
        
        nf.variables['xa'][:,:] = self.geom.xa[:,:] / self.Bohr
        nf.variables['cell'][:,:] = self.geom.cell[:,:] / self.Bohr

        # Get sparse format
        sp.variables['isc_off'][:] = self.geom.isc_off

        # Save data
        sp.variables['H'][:] = self.HS[:,0] / self.Ry
        sp.variables['S'][:] = self.HS[:,1]

        # Just to ensure that it is not a Gamma
        # point calculation
        st.variables['BZ'][:] = np.identity(3) * 2
        st.variables['BZ_displ'][:] = np.zeros([3],np.float)

        st.variables['ElectronicTemperature'][:] = 0.025 / self.Ry

        # Create the basis group
        ptbl = PeriodicTable()
        bs = nf.createGroup('BASIS')

        spec = self.geom._species_order()
        # Create list of species
        b = bs.createVariable('basis','i4',('na_u',))
        b[:] = np.array([spec[z] for z in self.geom.Z],np.int)
        bs.info = 'Basis of each atom by ID'
        for i,sp in enumerate(spec):
            s = bs.createGroup(ptbl.Z_short(sp))
            s.Atomic_number = np.int32(sp)
            s.ID = np.int32(i + 1)
            s.Element = ptbl.Z_short(sp)
            s.Label = ptbl.Z_short(sp)
            s.Mass = np.array(ptbl.atomic_mass(sp),np.float)
        nf.close()

    @classmethod
    def sparse2model(cls,geom,H,S):
        """ Returns a model based on the sparse matrices H and S """

        # Now create model, we set H to decide
        # the actual sparsity, hence we do
        H = H.tocsr()
        # Find max_n
        max_n = 0
        for i in range(geom.no_u):
            max_n = max(max_n,H[i,:].getnnz())
        H = H.tocoo()

        # Assign maximum size (we do it 2 times bigger
        # to enable the user to extend it a little)
        model = cls(geom,max_connection=max_n*2)

        # Copy data to the model
        for jo,io,h in zip(H.row,H.col,H.data):
            model[jo,io] = (h,S[jo,io])

        return model

    @classmethod
    def read_input(cls,input,geom=None):
        """
        Creates a TB model based on an ``TBInputFile`` object.

        The object should incorporate routines called `read_geom` and
        `read_model` to retrieve the geometry and the tight-binding matrix.
        """
        
        with input as fh:

            if geom is None:
                # Read in the structure
                geom = fh.read_geom(cls=cls._GEOM)

            # Read in tight-binding matrix
            return fh.read_model(geom=geom,cls=cls)


class TBT_dH(TBT_Model):
    """
    Hamiltonian model to create a dH Hamiltonian for TBtrans.

    This extends the class ``TBT_Model`` which contains a sparse
    Hamiltonian.
    
    Every parameter and attribute is the same as ``TBT_Model``.

    """
    def reset(self,dtype=np.float):
        """
        Overrides the ``TBT_Model`` method as the overlap matrix
        is not needed in the dH method for TBtrans.
        """
        # I know that this is not the most efficient way to
        # access a C-array, however, for constructing a
        # sparse pattern, it should be faster if memory elements
        # are closer... 
        # Hence, this choice of having H and S like this

        self._reset_sp()
        # Initialize HS size
        self.HS = np.empty((self.ptr[-1],1),dtype=dtype)

    @staticmethod
    def _add_lvl(nf,lvl=0):
        """
        Simply adds and returns a group if it does not
        exist it will be created
        """
        slvl = 'LEVEL-'+str(lvl)
        if not slvl in nf.groups:
            gr = nf.createGroup(slvl)
            if lvl in [2,4]:
                gr.createDimension('nkpt',None)
                v = gr.createVariable('kpt','f8',('nkpt','xyz'))
                v.info = 'k-points for dH values'
                v.unit = 'b**-1'
            if lvl in [3,4]: 
                gr.createDimension('ne',None)
                v = gr.createVariable('E','f8',('ne',))
                v.info = 'Energy points for dH values'
                v.unit = 'Ry'
        else:
            gr = nf.groups[slvl]
        return gr
        
    def save(self,fname,kpt=None,E=None,delete=False,zlib=0):
        """
        Saves/adds dH setting for the an energy level and or
        k-point.

        Parameters
        ----------
        fname  : str
            Filename to save the dH matrices in.
            If the file already exists it will append the
            data to the file by use of the ``kpt`` and ``E``
            parameters.
        kpt    : (None) [3] array_like, optional
            Saving the Hamiltonian for the k-point specified.
            If this is not None and ``E`` is None it will save the dH as level 2.
            If this is not None and ``E`` is not None it will save the dH as level 4
        E      : (None) float, optional
            Saving the Hamiltonian for the k-point specified.
            If this is not None and ``kpt`` is None it will save the dH as level 3.
            If this is not None and ``kpt`` is not None it will save the dH as level 4
        zlib   : (0) integer, optional
            When creating the filename, or a new level is added this denotes
            the compression of the dH matrix.
            This should be in the range [0;9] with 9 being the most compressed
            format.

        If both ``kpt`` and ``E`` are None it will save a level 1 dH.

        If the settings (``E`` and ``kpt``) for the dH matrix already exists for 
        the level it will overwrite the dH matrix.
            
        """
        # Be sure to have the sparsity pattern shrunk to the correct size
        self.finalize()

        if os.path.isfile(fname) and not delete:
            # The file already exists, so we append
            nf = nc.Dataset(fname,'a')
        else:
            nf = nc.Dataset(fname,'w',format='NETCDF4')
            nf.createDimension('xyz',3)
            nf.createDimension('no_u',self.geom.no_u)
        
        cmp_lvl = zlib
        z_lib = zlib > 0
    
        # find level
        if not kpt is None:
            if not E is None:
                # Level 4 
                lvl = 4
                dims = ('nkpt','ne','nnzs')
                chk_size = (1,1,len(self.col))
            else:
                # Level 2
                lvl = 2
                dims = ('nkpt','nnzs')
                chk_size = (1,len(self.col))
        elif not E is None:
            # Level 3
            lvl = 3
            dims = ('ne','nnzs')
            chk_size = (1,len(self.col))
        else:
            # Level 1
            lvl = 1
            dims = ('nnzs',)
            chk_size = (len(self.col),)

        # Add level
        glvl = self._add_lvl(nf,lvl)

        E_warn = False
        if lvl in [3,4]:
            all_E = np.array(glvl.variables['E'][:]) * self.Ry

            # Get energy index
            iE = 0
            if len(all_E) > 0:
                iE = np.argmin(np.abs(all_E - E))
                if abs(all_E[iE] - E) > 0.0001: # 0.1 meV accuracy...
                    # We add a new index
                    iE = len(all_E)
                else:
                    E_warn = True

        k_warn = False
        if lvl in [2,4]:
            all_k = np.array(glvl.variables['kpt'][:])
            
            # Get k-point index
            ik = 0
            if len(all_k) > 0:
                ik = np.argmin(np.sum(np.abs(all_k - kpt[None,:]),axis=-1))
                if abs(np.sum(np.abs(all_k[ik,:] - kpt))) > 0.0001:
                    # We add a new index
                    ik = len(all_k)
                else:
                    k_warn = True
                    
        if lvl == 4 and k_warn and E_warn and False:
            # As soon as we have put the second k-point and the first energy
            # point, this warning will proceed...
            # I.e. even though the variable has not been set, it will WARN
            # Hence we out-comment this for now...
            warnings.warn('Overwriting k-point {0} and energy point {1} correction.'.format(ik,iE), UserWarning) 
        elif lvl == 3 and E_warn:
            warnings.warn('Overwriting energy point {0} correction.'.format(iE), UserWarning) 
        elif lvl == 2 and k_warn:
            warnings.warn('Overwriting k-point {0} correction.'.format(ik), UserWarning) 
        
        # Check that the sparsity pattern for the Hamiltonian
        # matches the sparsity found in the file (if it exists)
        self._save_sparsity(glvl,zlib=zlib)

        # Save the Hamiltonian
        # Check for data type
        if np.iscomplexobj(self.HS):
            # We have it complex denoted by the user
            if not 'RedH' in glvl.variables:
                rH = glvl.createVariable('RedH','f8',dims,
                                         zlib=z_lib,complevel=cmp_lvl,
                                         chunksizes=chk_size)
                rH.info = 'Change in Hamiltonian'
                rH.unit = 'Ry'
                cH = glvl.createVariable('ImdH','f8',dims,
                                         zlib=z_lib,complevel=cmp_lvl,
                                         chunksizes=chk_size)
                cH.info = 'Change in Hamiltonian'
                cH.unit = 'Ry'
            else: 
                rH = glvl.variables['RedH']
                cH = glvl.variables['ImdH']
            # Save dH
            if   1 == lvl:
                rH[:] = self.HS[:,0].real / self.Ry
                cH[:] = self.HS[:,0].imag / self.Ry
            elif 2 == lvl:
                glvl.variables['kpt'][ik,:] = kpt[:]
                rH[ik,:] = self.HS[:,0].real / self.Ry
                cH[ik,:] = self.HS[:,0].imag / self.Ry
            elif 3 == lvl:
                glvl.variables['E'][iE] = E / self.Ry
                rH[iE,:] = self.HS[:,0].real / self.Ry
                cH[iE,:] = self.HS[:,0].imag / self.Ry
            elif 4 == lvl:
                glvl.variables['kpt'][ik,:] = kpt[:]
                glvl.variables['E'][iE] = E / self.Ry
                rH[ik,iE,:] = self.HS[:,0].real / self.Ry
                cH[ik,iE,:] = self.HS[:,0].imag / self.Ry
        else:
            # We have it complex denoted by the user
            if not 'dH' in glvl.variables:
                rH = glvl.createVariable('dH','f8',dims,
                                         zlib=z_lib,complevel=cmp_lvl,
                                         chunksizes=chk_size)
                rH.info = 'Change in Hamiltonian'
                rH.unit = 'Ry'
            else: 
                rH = glvl.variables['dH']
            # Save dH
            if   1 == lvl:
                rH[:] = self.HS[:,0] / self.Ry
            elif 2 == lvl:
                glvl.variables['kpt'][ik,:] = kpt[:]
                rH[ik,:] = self.HS[:,0] / self.Ry
            elif 3 == lvl:
                glvl.variables['E'][iE] = E / self.Ry
                rH[iE,:] = self.HS[:,0] / self.Ry
            elif 4 == lvl:
                glvl.variables['kpt'][ik,:] = kpt[:]
                glvl.variables['E'][iE] = E / self.Ry
                rH[ik,iE,:] = self.HS[:,0] / self.Ry

        # Cleanup
        nf.close()


class TBFile(object):
    """ Class to contain a file used in the tight-binding model """
    _mode = None
    def __init__(self,filename):
        self.file = filename

    def __enter__(self):
        """ Opens the output file and returns the handle """
        self.fh = open(self.file,self._mode)
        return self

    def __exit__(self, type, value, traceback):
        self.fh.close()
        del self.fh # clean-up so that it does not exist
        return False

class TBInputFile(TBFile):
    """ Class to easily open/close/read output files from programs """

    _mode = 'r'
    _comment = '#'

    def readline(self):
        """ Reads the next line of the file """
        l = self.fh.readline()
        while l.startswith(self._comment):
            l = self.fh.readline()
        return l

    def step_to(self,keyword):
        """ Steps the file-handle until the keyword is found in the output """
        # If keyword is a list, it just matches one of the inputs
        found = False
        if isinstance(keyword,(list,np.ndarray)):
            while not found:
                l = self.readline()
                for key in keyword:
                    found = found or (l.find(key) >= 0)
                if l == '': break # readline() keeps spitting out '' if EOF
                    
        else:
            while not found:
                l = self.readline()
                found = l.find(keyword) >= 0
                if l == '': break # readline() keeps spitting out '' if EOF
            
        # sometimes the line contains information, as a
        # default we return the line found
        return found, l

    def read_geom(self,cls=TBT_Geom):
        """ Reading a geometry in regular TB format """
        if not hasattr(self,'fh'):
            # The file-handle has not been opened
            with self as fh:
                return fh.read_geom(cls=cls)

        cell = np.zeros((3,3),np.float)
        Z = []
        xa = []
        n_orb = []

        nsc = np.zeros((3,),np.int)

        def Z2no(i,no):
            try:
                # pure atomic number
                return int(i),no
            except:
                # both atomic number and no
                j = i.replace('[',' ').replace(']',' ').split()
                return int(j[0]),int(j[1])
        
        # The format of the geometry file is
        keys = ['atoms','cell','supercells','nsc']
        for _ in range(len(keys)):
            f, l = self.step_to(keys)
            l = l.strip()
            if 'supercells' in l.lower() or 'nsc' in l.lower():
                # We have everything in one line
                l = l.split()[1:]
                for i in range(3): nsc[i] = int(l[i])
            elif 'cell' in l.lower():
                if 'begin' in l.lower():
                    for i in range(3):
                        l = self.readline().split()
                        cell[i,0] = float(l[0])
                        cell[i,1] = float(l[1])
                        cell[i,2] = float(l[2])
                    self.readline() # step past the block
                else:
                    # We have everything in one line
                    l = l.split()[1:]
                    for i in range(3):
                        cell[i,i] = float(l[i])
            elif 'atoms' in l.lower():
                l = self.readline()
                while not l.startswith('end'):
                    ls = l.split()
                    try:
                        no = int(ls[4])
                    except:
                        no = 1
                    z, no = Z2no(ls[0],no)
                    Z.append(z)
                    n_orb.append(no)
                    xa.append([float(f) for f in ls[1:4]])
                    l = self.readline()
                xa = np.array(xa,np.float)
                xa.shape = (-1,3)
                n_orb = np.array(n_orb,np.int)
                self.readline() # step past the block

        # Return the geometry
        geom = cls(cell,xa,Z=Z,n_orb=n_orb)
        geom.update(nsc=nsc)
        #for i, s in enumerate(sc):
        #    geom = geom.tile(s,axis=i)
        return geom

    def read_model(self,geom=None,hermitian=True,dtype=np.float,cls=TBT_Model):
        """ Abstract for reading a model """
        if not hasattr(self,'fh'):
            # The file-handle has not been opened
            with self as fh:
                return fh.read_model(geom=geom,dtype=dtype,cls=cls)

        if geom is None:
            geom = self.read_geom(cls=cls._GEOM)

        # With the geometry in place we can read in the entire matrix
        # Create a new sparse matrix
        from scipy.sparse import lil_matrix
        H = lil_matrix( (geom.no_u,geom.no_s) , dtype=dtype)
        S = lil_matrix( (geom.no_u,geom.no_s) , dtype=dtype)

        def i2o(geom,i):
            try:
                # pure orbital
                return int(i)
            except:
                # ia[o]
                # atom ia and the orbital o
                j = i.replace('[',' ').replace(']',' ').split()
                return geom.a2o(int(j[0])) + int(j[1])
        
        # Start reading in the supercells
        found, l = self.step_to('matrix')
        while found:
            # Get supercell
            ls = l.split()
            try:
                isc = np.array([int(ls[i]) for i in range(2,5)],np.int)
            except:
                isc = np.array([0,0,0],np.int)
            off1 = geom.sc_idx(isc) * geom.no_u
            off2 = geom.sc_idx(-isc) * geom.no_u
            l = self.readline()
            while not l.startswith('end'):
                ls = l.split()
                jo = i2o(geom,ls[0])
                io = i2o(geom,ls[1])
                h = float(ls[2])
                try:
                    s = float(ls[3])
                except:
                    s = 0.
                H[jo,io+off1] = h
                S[jo,io+off1] = s
                if hermitian: 
                    S[io,jo+off2] = s
                    H[io,jo+off2] = h
                l = self.readline()
            found, l = self.step_to('matrix')

        return cls.sparse2model(geom,H,S)


class TBOutputFile(TBFile):
    """ Class to easily open/close/read output files from programs """
    _mode = 'w'

    def write(self,*args):
        """
        Wrapper for the file-handle write statement

        Args passed directly to file()
        """
        self.fh.write(*args)

    def write_geom(self,geom,**kwargs):
        """
        Writes the geometry to the output file

        Parameters
        ----------
        geom: TBT_Geom
              The geometry we wish to write
        """
        if not hasattr(self,'fh'):
            # The file-handle has not been opened
            with self as fh:
                fh.write_geom(geom)
            return

        # The format of the geometry file is
        # for now, pretty stringent
        # Get cell_fmt
        cell_fmt = '.5f'
        if 'fmt' in kwargs: cell_fmt = kwargs['fmt']
        if 'cell_fmt' in kwargs: cell_fmt = kwargs['cell_fmt']
        xa_fmt = '.4e'
        if 'fmt' in kwargs: xa_fmt = kwargs['fmt']
        if 'xa_fmt' in kwargs: xa_fmt = kwargs['xa_fmt']


        self.write('begin cell\n')
        # Write the cell
        fmt_str = '  {{0:{0}}} {{1:{0}}} {{2:{0}}}\n'.format(cell_fmt)
        for i in range(3):
            self.write(fmt_str.format(*geom.cell[i,:]))
        self.write('end cell\n')

        # Write number of super cells in each direction
        self.write('\nsupercells {0:d} {1:d} {2:d}\n'.format(*(geom.nsc//2)))
        
        # Write all atomic positions along with the specie type
        self.write('\nbegin atoms\n')
        fmt1_str = '  {{0:d}} {{1:{0}}} {{2:{0}}} {{3:{0}}}\n'.format(xa_fmt)
        fmt2_str = '  {{0:d}}[{{1:d}}] {{2:{0}}} {{3:{0}}} {{4:{0}}}\n'.format(xa_fmt)

        for ia in range(geom.na_u):
            no = geom.n_orb[ia]
            if no == 1:
                self.write(fmt1_str.format(geom.Z[ia],*geom.xa[ia,:]))
            else:
                self.write(fmt2_str.format(geom.Z[ia],no,*geom.xa[ia,:]))

        self.write('end atoms\n')

    def write_model(self,model,hermitian=True,**kwargs):
        """ 
        Writes the model in the file according to the TB format.

        Parameters
        ----------
        model: TBT_Geom
           Writes the model to the file format. Saves the matrix specifications
        hermitian: boolean
           Whether the saved data should be written in a Hermitian way, or
           all data should be written.
           If this is true it will check the data for Hermiticity and decide
           based on that.
           By writing it Hermitianly we can reduce the written information
           by 50%.
        """
        if not hasattr(self,'fh'):
            # The file-handle has not been opened
            with self as fh:
                fh.write_model(model)
            return

        from scipy.sparse import triu

        # We default to the advanced layuot if we have more than one 
        # orbital on any one atom
        advanced = kwargs.get('advanced',np.any(model.geom.n_orb > 1))

        fmt = kwargs.get('fmt','g')
        if advanced:
            fmt1_str = ' {{0:d}}[{{1:d}}] {{2:d}}[{{3:d}}] {{4:{0}}}\n'.format(fmt)
            fmt2_str = ' {{0:d}}[{{1:d}}] {{2:d}}[{{3:d}}] {{4:{0}}} {{5:{0}}}\n'.format(fmt)
        else:
            fmt1_str = ' {{0:d}} {{1:d}} {{2:{0}}}\n'.format(fmt)
            fmt2_str = ' {{0:d}} {{1:d}} {{2:{0}}} {{3:{0}}}\n'.format(fmt)

        # Easier to retrieve elements
        geom = model.geom

        # We currently force the model to be finalized
        # before we can write it
        # This should be easily circumvented
        H, S = model.tocsr()
        # If the model is Hermitian we can
        # do with writing out half the entries
        if hermitian:
            herm_acc = kwargs.get('herm_acc',1e-6)
            # We check whether it is Hermitian
            for i, isc in enumerate(geom.isc_off):
                oi = i * geom.no_u
                oj = geom.sc_idx(-isc) * geom.no_u
                # get the difference between the ^\dagger elements
                diff = H[:,oi:oi+geom.no_u] - H[:,oj:oj+geom.no_u].transpose()
                diff.eliminate_zeros()
                diff = diff.tocoo()
                if np.any(np.abs(diff.data) > herm_acc):
                    amax = np.amax(np.abs(diff.data))
                    warnings.warn('The model could not be asserted to be Hermitian within the accuracy required ({0}).'.format(amax), UserWarning) 
                    hermitian = False
                del diff

        if hermitian:
            # Remove all double stuff
            for i, isc in enumerate(geom.isc_off):
                if np.any(isc < 0):
                    # We have ^\dagger element, remove it
                    o = i * geom.no_u
                    # Ensure that we remove all nullified quantities
                    # (setting elements to zero will add them internally
                    #  :(, hence this actually constructs the full matrix
                    # Therefore we do it on a row basis, to limit memory
                    # requirements
                    for j in xrange(geom.no_u):
                        H[j,o:o+geom.no_u] = 0.
                        H.eliminate_zeros()
                        S[j,o:o+geom.no_u] = 0.
                        S.eliminate_zeros()
            o = geom.sc_idx(np.zeros((3,),np.int))
            # Get upper-triangular matrix of the unit-cell H and S
            ut = triu(H[:,o:o+geom.no_u],k=0).tocsr()
            for j in xrange(geom.no_u):
                H[j,o:o+geom.no_u] = 0.
                H[j,o:o+geom.no_u] = ut[j,:]
                H.eliminate_zeros()
            ut = triu(S[:,o:o+geom.no_u],k=0).tocsr()
            for j in xrange(geom.no_u):
                S[j,o:o+geom.no_u] = 0.
                S[j,o:o+geom.no_u] = ut[j,:]
                S.eliminate_zeros()
            del ut
            
            # Ensure that S and H have the same sparsity pattern
            S = S.tocoo()
            for jo,io,s in zip(S.row,S.col,S.data):
                H[jo,io] = H[jo,io]
            S = S.tocsr()
                            
        # Start writing of the model
        # We loop on all super-cells
        for i, isc in enumerate(geom.isc_off):
            # Check that we have any contributions in this
            # sub-section
            Hsub = H[:,i*geom.no_u:(i+1)*geom.no_u].tocoo()
            Ssub = S[:,i*geom.no_u:(i+1)*geom.no_u].tocsr()
            if Hsub.getnnz() == 0: continue
            # We have a contribution, write out the information
            self.write('\nbegin matrix {0:d} {1:d} {2:d}\n'.format(*isc))
            if advanced:
                for jo,io,h in zip(Hsub.row,Hsub.col,Hsub.data):
                    s = Ssub[jo,io]
                    o = np.array([jo,io],np.int)
                    a = geom.o2a(o)
                    o = o - geom.a2o(a)
                    if s == 0.:
                        self.write(fmt1_str.format(a[0],o[0],a[1],o[1],h))
                    else:
                        self.write(fmt2_str.format(a[0],o[0],a[1],o[1],h,s))
            else:
                for jo,io,h in zip(Hsub.row,Hsub.col,Hsub.data):
                    s = Ssub[jo,io]
                    if s == 0.:
                        self.write(fmt1_str.format(jo,io,h))
                    else:
                        self.write(fmt2_str.format(jo,io,h,s))
            self.write('end matrix {0:d} {1:d} {2:d}\n'.format(*isc))


class PeriodicTable(object):
    """ 
    Very basic periodic table, not very pretty as it
    was generated using reg-exps.
    """
    _Z_int = {
        'Actinium' : 89 , 'Ac' : 89 , '89' : 89, 89 : 89,
        'Aluminum' : 13 , 'Al' : 13 , '13' : 13, 13 : 13,
        'Americium' : 95 , 'Am' : 95 , '95' : 95, 95 : 95,
        'Antimony' : 51 , 'Sb' : 51 , '51' : 51, 51 : 51,
        'Argon' : 18 , 'Ar' : 18 , '18' : 18, 18 : 18,
        'Arsenic' : 33 , 'As' : 33 , '33' : 33, 33 : 33,
        'Astatine' : 85 , 'At' : 85 , '85' : 85, 85 : 85,
        'Barium' : 56 , 'Ba' : 56 , '56' : 56, 56 : 56,
        'Berkelium' : 97 , 'Bk' : 97 , '97' : 97, 97 : 97,
        'Beryllium' : 4 , 'Be' : 4 , '4' : 4, 4 : 4,
        'Bismuth' : 83 , 'Bi' : 83 , '83' : 83, 83 : 83,
        'Bohrium' : 107 , 'Bh' : 107 , '107' : 107, 107 : 107,
        'Boron' : 5 , 'B' : 5 , '5' : 5, 5 : 5,
        'Bromine' : 35 , 'Br' : 35 , '35' : 35, 35 : 35,
        'Cadmium' : 48 , 'Cd' : 48 , '48' : 48, 48 : 48,
        'Calcium' : 20 , 'Ca' : 20 , '20' : 20, 20 : 20,
        'Californium' : 98 , 'Cf' : 98 , '98' : 98, 98 : 98,
        'Carbon' : 6 , 'C' : 6 , '6' : 6, 6 : 6,
        'Cerium' : 58 , 'Ce' : 58 , '58' : 58, 58 : 58,
        'Cesium' : 55 , 'Cs' : 55 , '55' : 55, 55 : 55,
        'Chlorine' : 17 , 'Cl' : 17 , '17' : 17, 17 : 17,
        'Chromium' : 24 , 'Cr' : 24 , '24' : 24, 24 : 24,
        'Cobalt' : 27 , 'Co' : 27 , '27' : 27, 27 : 27,
        'Copper' : 29 , 'Cu' : 29 , '29' : 29, 29 : 29,
        'Curium' : 96 , 'Cm' : 96 , '96' : 96, 96 : 96,
        'Darmstadtium' : 110 , 'Ds' : 110 , '110' : 110, 110 : 110,
        'Dubnium' : 105 , 'Db' : 105 , '105' : 105, 105 : 105,
        'Dysprosium' : 66 , 'Dy' : 66 , '66' : 66, 66 : 66,
        'Einsteinium' : 99 , 'Es' : 99 , '99' : 99, 99 : 99,
        'Erbium' : 68 , 'Er' : 68 , '68' : 68, 68 : 68,
        'Europium' : 63 , 'Eu' : 63 , '63' : 63, 63 : 63,
        'Fermium' : 100 , 'Fm' : 100 , '100' : 100, 100 : 100,
        'Fluorine' : 9 , 'F' : 9 , '9' : 9, 9 : 9,
        'Francium' : 87 , 'Fr' : 87 , '87' : 87, 87 : 87,
        'Gadolinium' : 64 , 'Gd' : 64 , '64' : 64, 64 : 64,
        'Gallium' : 31 , 'Ga' : 31 , '31' : 31, 31 : 31,
        'Germanium' : 32 , 'Ge' : 32 , '32' : 32, 32 : 32,
        'Gold' : 79 , 'Au' : 79 , '79' : 79, 79 : 79,
        'Hafnium' : 72 , 'Hf' : 72 , '72' : 72, 72 : 72,
        'Hassium' : 108 , 'Hs' : 108 , '108' : 108, 108 : 108,
        'Helium' : 2 , 'He' : 2 , '2' : 2, 2 : 2,
        'Holmium' : 67 , 'Ho' : 67 , '67' : 67, 67 : 67,
        'Hydrogen' : 1 , 'H' : 1 , '1' : 1, 1 : 1,
        'Indium' : 49 , 'In' : 49 , '49' : 49, 49 : 49,
        'Iodine' : 53 , 'I' : 53 , '53' : 53, 53 : 53,
        'Iridium' : 77 , 'Ir' : 77 , '77' : 77, 77 : 77,
        'Iron' : 26 , 'Fe' : 26 , '26' : 26, 26 : 26,
        'Krypton' : 36 , 'Kr' : 36 , '36' : 36, 36 : 36,
        'Lanthanum' : 57 , 'La' : 57 , '57' : 57, 57 : 57,
        'Lawrencium' : 103 , 'Lr' : 103 , '103' : 103, 103 : 103,
        'Lead' : 82 , 'Pb' : 82 , '82' : 82, 82 : 82,
        'Lithium' : 3 , 'Li' : 3 , '3' : 3, 3 : 3,
        'Lutetium' : 71 , 'Lu' : 71 , '71' : 71, 71 : 71,
        'Magnesium' : 12 , 'Mg' : 12 , '12' : 12, 12 : 12,
        'Manganese' : 25 , 'Mn' : 25 , '25' : 25, 25 : 25,
        'Meitnerium' : 109 , 'Mt' : 109 , '109' : 109, 109 : 109,
        'Mendelevium' : 101 , 'Md' : 101 , '101' : 101, 101 : 101,
        'Mercury' : 80 , 'Hg' : 80 , '80' : 80, 80 : 80,
        'Molybdenum' : 42 , 'Mo' : 42 , '42' : 42, 42 : 42,
        'Neodymium' : 60 , 'Nd' : 60 , '60' : 60, 60 : 60,
        'Neon' : 10 , 'Ne' : 10 , '10' : 10, 10 : 10,
        'Neptunium' : 93 , 'Np' : 93 , '93' : 93, 93 : 93,
        'Nickel' : 28 , 'Ni' : 28 , '28' : 28, 28 : 28,
        'Niobium' : 41 , 'Nb' : 41 , '41' : 41, 41 : 41,
        'Nitrogen' : 7 , 'N' : 7 , '7' : 7, 7 : 7,
        'Nobelium' : 102 , 'No' : 102 , '102' : 102, 102 : 102,
        'Osmium' : 76 , 'Os' : 76 , '76' : 76, 76 : 76,
        'Oxygen' : 8 , 'O' : 8 , '8' : 8, 8 : 8,
        'Palladium' : 46 , 'Pd' : 46 , '46' : 46, 46 : 46,
        'Phosphorus' : 15 , 'P' : 15 , '15' : 15, 15 : 15,
        'Platinum' : 78 , 'Pt' : 78 , '78' : 78, 78 : 78,
        'Plutonium' : 94 , 'Pu' : 94 , '94' : 94, 94 : 94,
        'Polonium' : 84 , 'Po' : 84 , '84' : 84, 84 : 84,
        'Potassium' : 19 , 'K' : 19 , '19' : 19, 19 : 19,
        'Praseodymium' : 59 , 'Pr' : 59 , '59' : 59, 59 : 59,
        'Promethium' : 61 , 'Pm' : 61 , '61' : 61, 61 : 61,
        'Protactinium' : 91 , 'Pa' : 91 , '91' : 91, 91 : 91,
        'Radium' : 88 , 'Ra' : 88 , '88' : 88, 88 : 88,
        'Radon' : 86 , 'Rn' : 86 , '86' : 86, 86 : 86,
        'Rhenium' : 75 , 'Re' : 75 , '75' : 75, 75 : 75,
        'Rhodium' : 45 , 'Rh' : 45 , '45' : 45, 45 : 45,
        'Rubidium' : 37 , 'Rb' : 37 , '37' : 37, 37 : 37,
        'Ruthenium' : 44 , 'Ru' : 44 , '44' : 44, 44 : 44,
        'Rutherfordium' : 104 , 'Rf' : 104 , '104' : 104, 104 : 104,
        'Samarium' : 62 , 'Sm' : 62 , '62' : 62, 62 : 62,
        'Scandium' : 21 , 'Sc' : 21 , '21' : 21, 21 : 21,
        'Seaborgium' : 106 , 'Sg' : 106 , '106' : 106, 106 : 106,
        'Selenium' : 34 , 'Se' : 34 , '34' : 34, 34 : 34,
        'Silicon' : 14 , 'Si' : 14 , '14' : 14, 14 : 14,
        'Silver' : 47 , 'Ag' : 47 , '47' : 47, 47 : 47,
        'Sodium' : 11 , 'Na' : 11 , '11' : 11, 11 : 11,
        'Strontium' : 38 , 'Sr' : 38 , '38' : 38, 38 : 38,
        'Sulfur' : 16 , 'S' : 16 , '16' : 16, 16 : 16,
        'Tantalum' : 73 , 'Ta' : 73 , '73' : 73, 73 : 73,
        'Technetium' : 43 , 'Tc' : 43 , '43' : 43, 43 : 43,
        'Tellurium' : 52 , 'Te' : 52 , '52' : 52, 52 : 52,
        'Terbium' : 65 , 'Tb' : 65 , '65' : 65, 65 : 65,
        'Thallium' : 81 , 'Tl' : 81 , '81' : 81, 81 : 81,
        'Thorium' : 90 , 'Th' : 90 , '90' : 90, 90 : 90,
        'Thulium' : 69 , 'Tm' : 69 , '69' : 69, 69 : 69,
        'Tin' : 50 , 'Sn' : 50 , '50' : 50, 50 : 50,
        'Titanium' : 22 , 'Ti' : 22 , '22' : 22, 22 : 22,
        'Tungsten' : 74 , 'W' : 74 , '74' : 74, 74 : 74,
        'Ununbium' : 112 , 'Uub' : 112 , '112' : 112, 112 : 112,
        'Ununhexium' : 116 , 'Uuh' : 116 , '116' : 116, 116 : 116,
        'Ununoctium' : 118 , 'Uuo' : 118 , '118' : 118, 118 : 118,
        'Ununpentium' : 115 , 'Uup' : 115 , '115' : 115, 115 : 115,
        'Ununquadium' : 114 , 'Uuq' : 114 , '114' : 114, 114 : 114,
        'Ununseptium' : 117 , 'Uus' : 117 , '117' : 117, 117 : 117,
        'Ununtrium' : 113 , 'Uut' : 113 , '113' : 113, 113 : 113,
        'Ununium' : 111 , 'Uuu' : 111 , '111' : 111, 111 : 111,
        'Uranium' : 92 , 'U' : 92 , '92' : 92, 92 : 92,
        'Vanadium' : 23 , 'V' : 23 , '23' : 23, 23 : 23,
        'Xenon' : 54 , 'Xe' : 54 , '54' : 54, 54 : 54,
        'Ytterbium' : 70 , 'Yb' : 70 , '70' : 70, 70 : 70,
        'Yttrium' : 39 , 'Y' : 39 , '39' : 39, 39 : 39,
        'Zinc' : 30 , 'Zn' : 30 , '30' : 30, 30 : 30,
        'Zirconium' : 40 , 'Zr' : 40 , '40' : 40, 40 : 40,
        }
    
    _Z_short = {
        'Actinium' : 'Ac' , 'Ac' : 'Ac' , '89' : 'Ac', 89 : 'Ac',
        'Aluminum' : 'Al' , 'Al' : 'Al' , '13' : 'Al', 13 : 'Al',
        'Americium' : 'Am' , 'Am' : 'Am' , '95' : 'Am', 95 : 'Am',
        'Antimony' : 'Sb' , 'Sb' : 'Sb' , '51' : 'Sb', 51 : 'Sb',
        'Argon' : 'Ar' , 'Ar' : 'Ar' , '18' : 'Ar', 18 : 'Ar',
        'Arsenic' : 'As' , 'As' : 'As' , '33' : 'As', 33 : 'As',
        'Astatine' : 'At' , 'At' : 'At' , '85' : 'At', 85 : 'At',
        'Barium' : 'Ba' , 'Ba' : 'Ba' , '56' : 'Ba', 56 : 'Ba',
        'Berkelium' : 'Bk' , 'Bk' : 'Bk' , '97' : 'Bk', 97 : 'Bk',
        'Beryllium' : 'Be' , 'Be' : 'Be' , '4' : 'Be', 4 : 'Be',
        'Bismuth' : 'Bi' , 'Bi' : 'Bi' , '83' : 'Bi', 83 : 'Bi',
        'Bohrium' : 'Bh' , 'Bh' : 'Bh' , '107' : 'Bh', 107 : 'Bh',
        'Boron' : 'B' , 'B' : 'B' , '5' : 'B', 5 : 'B',
        'Bromine' : 'Br' , 'Br' : 'Br' , '35' : 'Br', 35 : 'Br',
        'Cadmium' : 'Cd' , 'Cd' : 'Cd' , '48' : 'Cd', 48 : 'Cd',
        'Calcium' : 'Ca' , 'Ca' : 'Ca' , '20' : 'Ca', 20 : 'Ca',
        'Californium' : 'Cf' , 'Cf' : 'Cf' , '98' : 'Cf', 98 : 'Cf',
        'Carbon' : 'C' , 'C' : 'C' , '6' : 'C', 6 : 'C',
        'Cerium' : 'Ce' , 'Ce' : 'Ce' , '58' : 'Ce', 58 : 'Ce',
        'Cesium' : 'Cs' , 'Cs' : 'Cs' , '55' : 'Cs', 55 : 'Cs',
        'Chlorine' : 'Cl' , 'Cl' : 'Cl' , '17' : 'Cl', 17 : 'Cl',
        'Chromium' : 'Cr' , 'Cr' : 'Cr' , '24' : 'Cr', 24 : 'Cr',
        'Cobalt' : 'Co' , 'Co' : 'Co' , '27' : 'Co', 27 : 'Co',
        'Copper' : 'Cu' , 'Cu' : 'Cu' , '29' : 'Cu', 29 : 'Cu',
        'Curium' : 'Cm' , 'Cm' : 'Cm' , '96' : 'Cm', 96 : 'Cm',
        'Darmstadtium' : 'Ds' , 'Ds' : 'Ds' , '110' : 'Ds', 110 : 'Ds',
        'Dubnium' : 'Db' , 'Db' : 'Db' , '105' : 'Db', 105 : 'Db',
        'Dysprosium' : 'Dy' , 'Dy' : 'Dy' , '66' : 'Dy', 66 : 'Dy',
        'Einsteinium' : 'Es' , 'Es' : 'Es' , '99' : 'Es', 99 : 'Es',
        'Erbium' : 'Er' , 'Er' : 'Er' , '68' : 'Er', 68 : 'Er',
        'Europium' : 'Eu' , 'Eu' : 'Eu' , '63' : 'Eu', 63 : 'Eu',
        'Fermium' : 'Fm' , 'Fm' : 'Fm' , '100' : 'Fm', 100 : 'Fm',
        'Fluorine' : 'F' , 'F' : 'F' , '9' : 'F', 9 : 'F',
        'Francium' : 'Fr' , 'Fr' : 'Fr' , '87' : 'Fr', 87 : 'Fr',
        'Gadolinium' : 'Gd' , 'Gd' : 'Gd' , '64' : 'Gd', 64 : 'Gd',
        'Gallium' : 'Ga' , 'Ga' : 'Ga' , '31' : 'Ga', 31 : 'Ga',
        'Germanium' : 'Ge' , 'Ge' : 'Ge' , '32' : 'Ge', 32 : 'Ge',
        'Gold' : 'Au' , 'Au' : 'Au' , '79' : 'Au', 79 : 'Au',
        'Hafnium' : 'Hf' , 'Hf' : 'Hf' , '72' : 'Hf', 72 : 'Hf',
        'Hassium' : 'Hs' , 'Hs' : 'Hs' , '108' : 'Hs', 108 : 'Hs',
        'Helium' : 'He' , 'He' : 'He' , '2' : 'He', 2 : 'He',
        'Holmium' : 'Ho' , 'Ho' : 'Ho' , '67' : 'Ho', 67 : 'Ho',
        'Hydrogen' : 'H' , 'H' : 'H' , '1' : 'H', 1 : 'H',
        'Indium' : 'In' , 'In' : 'In' , '49' : 'In', 49 : 'In',
        'Iodine' : 'I' , 'I' : 'I' , '53' : 'I', 53 : 'I',
        'Iridium' : 'Ir' , 'Ir' : 'Ir' , '77' : 'Ir', 77 : 'Ir',
        'Iron' : 'Fe' , 'Fe' : 'Fe' , '26' : 'Fe', 26 : 'Fe',
        'Krypton' : 'Kr' , 'Kr' : 'Kr' , '36' : 'Kr', 36 : 'Kr',
        'Lanthanum' : 'La' , 'La' : 'La' , '57' : 'La', 57 : 'La',
        'Lawrencium' : 'Lr' , 'Lr' : 'Lr' , '103' : 'Lr', 103 : 'Lr',
        'Lead' : 'Pb' , 'Pb' : 'Pb' , '82' : 'Pb', 82 : 'Pb',
        'Lithium' : 'Li' , 'Li' : 'Li' , '3' : 'Li', 3 : 'Li',
        'Lutetium' : 'Lu' , 'Lu' : 'Lu' , '71' : 'Lu', 71 : 'Lu',
        'Magnesium' : 'Mg' , 'Mg' : 'Mg' , '12' : 'Mg', 12 : 'Mg',
        'Manganese' : 'Mn' , 'Mn' : 'Mn' , '25' : 'Mn', 25 : 'Mn',
        'Meitnerium' : 'Mt' , 'Mt' : 'Mt' , '109' : 'Mt', 109 : 'Mt',
        'Mendelevium' : 'Md' , 'Md' : 'Md' , '101' : 'Md', 101 : 'Md',
        'Mercury' : 'Hg' , 'Hg' : 'Hg' , '80' : 'Hg', 80 : 'Hg',
        'Molybdenum' : 'Mo' , 'Mo' : 'Mo' , '42' : 'Mo', 42 : 'Mo',
        'Neodymium' : 'Nd' , 'Nd' : 'Nd' , '60' : 'Nd', 60 : 'Nd',
        'Neon' : 'Ne' , 'Ne' : 'Ne' , '10' : 'Ne', 10 : 'Ne',
        'Neptunium' : 'Np' , 'Np' : 'Np' , '93' : 'Np', 93 : 'Np',
        'Nickel' : 'Ni' , 'Ni' : 'Ni' , '28' : 'Ni', 28 : 'Ni',
        'Niobium' : 'Nb' , 'Nb' : 'Nb' , '41' : 'Nb', 41 : 'Nb',
        'Nitrogen' : 'N' , 'N' : 'N' , '7' : 'N', 7 : 'N',
        'Nobelium' : 'No' , 'No' : 'No' , '102' : 'No', 102 : 'No',
        'Osmium' : 'Os' , 'Os' : 'Os' , '76' : 'Os', 76 : 'Os',
        'Oxygen' : 'O' , 'O' : 'O' , '8' : 'O', 8 : 'O',
        'Palladium' : 'Pd' , 'Pd' : 'Pd' , '46' : 'Pd', 46 : 'Pd',
        'Phosphorus' : 'P' , 'P' : 'P' , '15' : 'P', 15 : 'P',
        'Platinum' : 'Pt' , 'Pt' : 'Pt' , '78' : 'Pt', 78 : 'Pt',
        'Plutonium' : 'Pu' , 'Pu' : 'Pu' , '94' : 'Pu', 94 : 'Pu',
        'Polonium' : 'Po' , 'Po' : 'Po' , '84' : 'Po', 84 : 'Po',
        'Potassium' : 'K' , 'K' : 'K' , '19' : 'K', 19 : 'K',
        'Praseodymium' : 'Pr' , 'Pr' : 'Pr' , '59' : 'Pr', 59 : 'Pr',
        'Promethium' : 'Pm' , 'Pm' : 'Pm' , '61' : 'Pm', 61 : 'Pm',
        'Protactinium' : 'Pa' , 'Pa' : 'Pa' , '91' : 'Pa', 91 : 'Pa',
        'Radium' : 'Ra' , 'Ra' : 'Ra' , '88' : 'Ra', 88 : 'Ra',
        'Radon' : 'Rn' , 'Rn' : 'Rn' , '86' : 'Rn', 86 : 'Rn',
        'Rhenium' : 'Re' , 'Re' : 'Re' , '75' : 'Re', 75 : 'Re',
        'Rhodium' : 'Rh' , 'Rh' : 'Rh' , '45' : 'Rh', 45 : 'Rh',
        'Rubidium' : 'Rb' , 'Rb' : 'Rb' , '37' : 'Rb', 37 : 'Rb',
        'Ruthenium' : 'Ru' , 'Ru' : 'Ru' , '44' : 'Ru', 44 : 'Ru',
        'Rutherfordium' : 'Rf' , 'Rf' : 'Rf' , '104' : 'Rf', 104 : 'Rf',
        'Samarium' : 'Sm' , 'Sm' : 'Sm' , '62' : 'Sm', 62 : 'Sm',
        'Scandium' : 'Sc' , 'Sc' : 'Sc' , '21' : 'Sc', 21 : 'Sc',
        'Seaborgium' : 'Sg' , 'Sg' : 'Sg' , '106' : 'Sg', 106 : 'Sg',
        'Selenium' : 'Se' , 'Se' : 'Se' , '34' : 'Se', 34 : 'Se',
        'Silicon' : 'Si' , 'Si' : 'Si' , '14' : 'Si', 14 : 'Si',
        'Silver' : 'Ag' , 'Ag' : 'Ag' , '47' : 'Ag', 47 : 'Ag',
        'Sodium' : 'Na' , 'Na' : 'Na' , '11' : 'Na', 11 : 'Na',
        'Strontium' : 'Sr' , 'Sr' : 'Sr' , '38' : 'Sr', 38 : 'Sr',
        'Sulfur' : 'S' , 'S' : 'S' , '16' : 'S', 16 : 'S',
        'Tantalum' : 'Ta' , 'Ta' : 'Ta' , '73' : 'Ta', 73 : 'Ta',
        'Technetium' : 'Tc' , 'Tc' : 'Tc' , '43' : 'Tc', 43 : 'Tc',
        'Tellurium' : 'Te' , 'Te' : 'Te' , '52' : 'Te', 52 : 'Te',
        'Terbium' : 'Tb' , 'Tb' : 'Tb' , '65' : 'Tb', 65 : 'Tb',
        'Thallium' : 'Tl' , 'Tl' : 'Tl' , '81' : 'Tl', 81 : 'Tl',
        'Thorium' : 'Th' , 'Th' : 'Th' , '90' : 'Th', 90 : 'Th',
        'Thulium' : 'Tm' , 'Tm' : 'Tm' , '69' : 'Tm', 69 : 'Tm',
        'Tin' : 'Sn' , 'Sn' : 'Sn' , '50' : 'Sn', 50 : 'Sn',
        'Titanium' : 'Ti' , 'Ti' : 'Ti' , '22' : 'Ti', 22 : 'Ti',
        'Tungsten' : 'W' , 'W' : 'W' , '74' : 'W', 74 : 'W',
        'Ununbium' : 'Uub' , 'Uub' : 'Uub' , '112' : 'Uub', 112 : 'Uub',
        'Ununhexium' : 'Uuh' , 'Uuh' : 'Uuh' , '116' : 'Uuh', 116 : 'Uuh',
        'Ununoctium' : 'Uuo' , 'Uuo' : 'Uuo' , '118' : 'Uuo', 118 : 'Uuo',
        'Ununpentium' : 'Uup' , 'Uup' : 'Uup' , '115' : 'Uup', 115 : 'Uup',
        'Ununquadium' : 'Uuq' , 'Uuq' : 'Uuq' , '114' : 'Uuq', 114 : 'Uuq',
        'Ununseptium' : 'Uus' , 'Uus' : 'Uus' , '117' : 'Uus', 117 : 'Uus',
        'Ununtrium' : 'Uut' , 'Uut' : 'Uut' , '113' : 'Uut', 113 : 'Uut',
        'Ununium' : 'Uuu' , 'Uuu' : 'Uuu' , '111' : 'Uuu', 111 : 'Uuu',
        'Uranium' : 'U' , 'U' : 'U' , '92' : 'U', 92 : 'U',
        'Vanadium' : 'V' , 'V' : 'V' , '23' : 'V', 23 : 'V',
        'Xenon' : 'Xe' , 'Xe' : 'Xe' , '54' : 'Xe', 54 : 'Xe',
        'Ytterbium' : 'Yb' , 'Yb' : 'Yb' , '70' : 'Yb', 70 : 'Yb',
        'Yttrium' : 'Y' , 'Y' : 'Y' , '39' : 'Y', 39 : 'Y',
        'Zinc' : 'Zn' , 'Zn' : 'Zn' , '30' : 'Zn', 30 : 'Zn',
        'Zirconium' : 'Zr' , 'Zr' : 'Zr' , '40' : 'Zr', 40 : 'Zr',
        }

    _atomic_mass = {
        1 : 1.00794 ,
        2 : 4.002602 ,
        3 : 6.941 ,
        4 : 9.012182 ,
        5 : 10.811 ,
        6 : 12.0107 ,
        7 : 14.0067 ,
        8 : 15.9994 ,
        9 : 18.9984032 ,
        10 : 20.1797 ,
        11 : 22.98976928 ,
        12 : 24.3050 ,
        13 : 26.9815386 ,
        14 : 28.0855 ,
        15 : 30.973762 ,
        16 : 32.065 ,
        17 : 35.453 ,
        18 : 39.948 ,
        19 : 39.0983 ,
        20 : 40.078 ,
        21 : 44.955912 ,
        22 : 47.867 ,
        23 : 50.9415 ,
        24 : 51.9961 ,
        25 : 54.938045 ,
        26 : 55.845 ,
        27 : 58.933195 ,
        28 : 58.6934 ,
        29 : 63.546 ,
        30 : 65.409 ,
        31 : 69.723 ,
        32 : 72.64 ,
        33 : 74.92160 ,
        34 : 78.96 ,
        35 : 79.904 ,
        36 : 83.798 ,
        37 : 85.4678 ,
        38 : 87.62 ,
        39 : 88.90585 ,
        40 : 91.224 ,
        41 : 92.906 ,
        42 : 95.94 ,
        43 : 98. ,
        44 : 101.07 ,
        45 : 102.905 ,
        46 : 106.42 ,
        47 : 107.8682 ,
        48 : 112.411 ,
        49 : 114.818 ,
        50 : 118.710 ,
        51 : 121.760 ,
        52 : 127.60 ,
        53 : 126.904 ,
        54 : 131.293 ,
        55 : 132.9054519 ,
        56 : 137.327 ,
        57 : 138.90547 ,
        58 : 140.116 ,
        59 : 140.90765 ,
        60 : 144.242 ,
        61 : 145. ,
        62 : 150.36 ,
        63 : 151.964 ,
        64 : 157.25 ,
        65 : 158.92535 ,
        66 : 162.500 ,
        67 : 164.930 ,
        68 : 167.259 ,
        69 : 168.93421 ,
        70 : 173.04 ,
        71 : 174.967 ,
        72 : 178.49 ,
        73 : 180.94788 ,
        74 : 183.84 ,
        75 : 186.207 ,
        76 : 190.23 ,
        77 : 192.217 ,
        78 : 195.084 ,
        79 : 196.966569 ,
        80 : 200.59 ,
        81 : 204.3833 ,
        82 : 207.2 ,
        83 : 208.98040 ,
        84 : 210. ,
        85 : 210. ,
        86 : 220. ,
        87 : 223. ,
        88 : 226. ,
        89 : 227. ,
        91 : 231.03588 ,
        90 : 232.03806 ,
        93 : 237. ,
        92 : 238.02891 ,
        95 : 243. ,
        94 : 244. ,
        96 : 247. ,
        97 : 247. ,
        98 : 251. ,
        99 : 252. ,
        100 : 257. ,
        101 : 258. ,
        102 : 259. ,
        103 : 262. ,
        104 : 261. ,
        105 : 262. ,
        106 : 266. ,
        107 : 264. ,
        108 : 277. ,
        109 : 268. ,
        110 : 271. ,
        111 : 272. ,
        112 : 285. ,
        113 : 284. ,
        114 : 289. ,
        115 : 288. ,
        116 : 292. ,
        118 : 293. ,
        }

    def Z_int(self,key):
        """ Returns the Z number """
        ak = np.asarray([key]).flatten()
        if len(ak) == 1: return np.int32(self._Z_int[ak[0]])
        return np.array([self._Z_int[i] for i in ak],np.int32)

    Z = Z_int

    def Z_short(self,key):
        """ Returns the Z name in short """
        ak = np.asarray([key])
        ak.shape = (-1,) # flatten it
        if len(ak) == 1: return self._Z_short[ak[0]]
        return [self._Z_short[i] for i in ak]

    def atomic_mass(self,key):
        Z = self.Z_int(key)
        if isinstance(Z,(int,np.int,np.int32)): return self._atomic_mass[Z]
        return np.array([self._atomic_mass[i] for i in Z])


# According to 
#  PRB. 81, 245402 (2010)
# we define A-G different sets of
# TB parameters for graphene.
# Our models will from this create a 
# TB input file for tbtrans
_TB_graphene = {
    # set A
    'A' : {
        # Nearest neighbour
        'n1' : -2.7, 
        # next nearest neighbour
        'n2' : 0. ,
        # next-next nearest neighbour
        'n3' : 0. ,
        # overlap (same as neigbour intgers)
        's1' : 0. ,
        's2' : 0. ,
        's3' : 0. ,
        # hopping to an armchair edge 
        'eA' : -2.7,
        'eZ' : -2.7,
        # Hubbard U
        'U'  : 0. ,
        'Ef' : 0.,
        },
    }
# Define set B
_TB_graphene['B'] = copy.deepcopy(_TB_graphene['A'])
_TB_graphene['B']['U'] = 2.0
_TB_graphene['B']['Ef'] = 2.
# Define set C
_TB_graphene['C'] = copy.deepcopy(_TB_graphene['B'])
_TB_graphene['C']['n2'] = -0.2
_TB_graphene['C']['Ef'] = 2.6
# Define set D
_TB_graphene['D'] = copy.deepcopy(_TB_graphene['C'])
_TB_graphene['D']['n3'] = -0.18
# Define set E
_TB_graphene['E'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['E']['eA'] = 1.06 * _TB_graphene['E']['n1']
_TB_graphene['E']['eZ'] = 1.03 * _TB_graphene['E']['n1']
# Define set F
_TB_graphene['F'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['F'].update({
        'n2' : -0.09 ,
        'n3' : -0.27 ,
        's1' : 0.11 ,
        's2' : 0.045,
        's3' : 0.065,
        'Ef' : 2.62427745665,
        })
# Define set G
_TB_graphene['G'] = copy.deepcopy(_TB_graphene['D'])
_TB_graphene['G'].update({
        'n1' : -2.97 ,
        'n2' : -0.073,
        'n3' : -0.33 ,
        's1' : 0.073,
        's2' : 0.018,
        's3' : 0.026,
        'U'  : 0.   ,
        'Ef' : 0.231501057082,
        })

# To get the Fermi levels we calculate the first eigenvalue at
# the K-point (the Dirac point is the Fermi-level)
#uc_gr = graphene_uc(alat=alat,square=False))
#H, S = uc_gr.tocsr([1./3,2./3.,0])
#EF = sp.linalg.eigh(H.todense(),S.todense(),eigvals_only=True,overwrite_a=False,overwrite_b=False)[0]


# Define a generic geometry for a square graphene unit-cell
# To create any arbitrary unit-cell, simple use the repeat
# function. :)
def graphene_uc(alat=1.42,square=True):
    """
    Returns a generic graphene unit-cell with user set lattice
    parameter.
    """
    sq3h  = 3.**.5 * 0.5
    if square:
        gr = TBT_Geom(xa=np.array([[ 0.,   0., 0.],
                                   [ 2.,   0., 0.],
                                   [0.5, sq3h, 0.],
                                   [1.5, sq3h, 0.] ],np.float),
                      cell=np.array([[3.,     0.,  0.],
                                     [0., 2*sq3h,  0.],
                                     [0.,     0., 10.]],np.float),
                      Z = 'Carbon',
                      dR=2.05) # third nearest neighbour
    else:
        gr = TBT_Geom(xa=np.array([[ 0., 0., 0.],
                                   [ 1., 0., 0.]],np.float),
                      cell=np.array([[1.5, sq3h,  0.],
                                     [1.5,-sq3h,  0.],
                                     [ 0.,   0., 10.]],np.float),
                      Z = 'Carbon',
                      dR=2.05) # third nearest neighbour
    gr.xa   *= alat
    gr.cell *= alat
    gr.dR   *= alat
    gr.update()
    return gr

def TB_save(fname,Geom,TB = _TB_graphene['D'],alat=1.42,save_tb=True):
    """ 
    Creates a TB SIESTA.nc file with a system of a geometry.
    It will automatically create a sparsity pattern based
    on the tight-binding parameter set provided through TB.
    """

    sq3h  = 3.**.5 * 0.5

    # Print out the differences with respect to the first
    #print('dR from 0: ',np.linalg.norm(Geom.xa-Geom.xa[0,:][None,:],axis=-1))

    # Create the sparsity pattern.
    # The regular scipy sparse patterns does not 
    # allow entering elements with zero value.
    # Hence we need to build it our-selves :(

    # In our one orbital model this will do
    HS = TBT_Model(Geom,max_connection = 20)

    # When setting the hopping and overlap you do it by 
    # a tuple assignment
    # Hence:
    #   HS[i,j] = (H,S)
    # means that the i'th orbital connecting with the j'th
    # has hopping energy H and overlap S

    # Create tuple of connection ranges (this is for graphene)
    dR   = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    on   = (TB['U'] ,1.)
    nn   = (TB['n1'],TB['s1'])
    nnn  = (TB['n2'],TB['s2'])
    nnnn = (TB['n3'],TB['s3'])

    # We add all hoppings
    for ias, idxs in Geom:
        for ia in ias:
            # Retrieve all hoppings (in one go)
            idx_a = Geom.close_all(ia,dR=dR,idx=idxs)
            # set all on-site hoppings
            HS[ia,idx_a[0]] = on
            # set all nearest hoppings
            HS[ia,idx_a[1]] = nn
            # set all next-nearest hoppings
            HS[ia,idx_a[2]] = nnn
            # set all next-next-nearest hoppings
            HS[ia,idx_a[3]] = nnn

    # This concludes the sparsity pattern
    # Save it
    HS.save(fname,Ef=TB['Ef'],overwrite=True)
    if save_tb:
        with TBOutputFile(fname.replace('.nc','.tb')) as fh:
            fh.write_geom(HS.geom)
            fh.write_model(HS)

def TB_square():
    """
    This simple example is the same as given in the manual
    for TBtrans.
    So follow the explanations there carefully and you should 
    be able to handle arbitrary systems
    """
    
    # Create a square unit cell with
    # nearest neighbour interactions,
    # and interatomic separation of 1. Ang
    cell = np.identity(3,np.float)
    cell[2,2] = 2.
    SQ = TBT_Geom(xa=np.zeros([1,3],np.float),
                  cell=cell, Z='Au' , dR=1.1)
    
    # Extend the square lattice to a
    # 2 by 1 electrode [x by y]
    el  = SQ.repeat(2,axis=0)
    # Create the device by making 1 by 3 times the electrode
    # [ x by y ]
    dev = el.tile(3,axis=1)
    
    # Create the TB models
    TB_el  = TBT_Model(el)
    TB_dev = TBT_Model(dev)
    
    # set TB parameters
    # In the following we set the TB 
    # manually, however, further down we
    # also create them in an easier way
    # The point is to learn how the sparsity pattern
    # is setup.

    U  =  0.
    t1 = -0.5
    # electrode:
    #   on-site
    for io in range(el.no_u):
        TB_el[io,io] = (U,1.)
    #  1 -> 2
    TB_el[0,1] = (t1,0.)
    #  2 -> 1
    TB_el[1,0] = (t1,0.)
    #  1 -> 2 in super-cell [-1,0] and [1,0]
    # First we get supercell offset for the [-1,0] cell
    sc = el.sc_idx([-1,0,0]) * el.no_u
    TB_el[0,sc+1] = (t1,0.)
    sc = el.sc_idx([1,0,0]) * el.no_u
    TB_el[1,sc+0] = (t1,0.)
    # 1 -> 1, 2 -> 2
    #  in super-cell [0,-1] and [0,1]
    sc = el.sc_idx([0,-1,0]) * el.no_u
    TB_el[0,sc+0] = (t1,0.)
    TB_el[1,sc+1] = (t1,0.)
    sc = el.sc_idx([0,1,0]) * el.no_u
    TB_el[0,sc+0] = (t1,0.)
    TB_el[1,sc+1] = (t1,0.)
    
    # This finalizes the TB parameters for a
    # unit-cell with 2 atoms.
    # To recap, each atom connects with 4 
    # neighbouring atoms totalling in us
    # needing to set 8 elements (and we did!)

    # Here I show how the exact same thing can
    # be achieved by using atomic coordinates
    # to determine the integral hoppings,
    # first we define the range of hoppings
    #  on-site hoppings must be of atoms within 0.1 Ang of
    #          other atoms
    #  nearest neighbour hoppings must be of atoms within 1.1 Ang
    #          of other atoms
    #     on-site , nearest neighbour
    dR = (  0.1   ,     1.1          )
    # NOTE, this below loop does EVERYTHING you did above!
    on = (U ,1.)
    nn = (t1,0.)
    for ia in xrange(el.na_u):
        idx_a = el.close_all(ia,dR=dR)
        # now idx_a is a list of two indices
        #  idx_a[0] is an index list containing all atoms 
        #           connecting to 'ia' within 0.1 Ang
        #  idx_a[1] is an index list containing all atoms
        #           connection to 'ia' within 1.1 Ang
        # Hence we can set the hopping integrals like this
        TB_el[ia,idx_a[0]] = on
        TB_el[ia,idx_a[1]] = nn

    # Now we just do the same thing for the device
    for ia in xrange(dev.na_u):
        idx_a = dev.close_all(ia,dR=dR)
        # now idx_a is a list of two indices
        #  idx_a[0] is an index list containing all atoms 
        #           connecting to 'ia' within 0.1 Ang
        #  idx_a[1] is an index list containing all atoms
        #           connection to 'ia' within 1.1 Ang
        # Hence we can set the hopping integrals like this
        TB_dev[ia,idx_a[0]] = on
        TB_dev[ia,idx_a[1]] = nn
        
    # And DONE, you have now created your first input for
    # tbtrans with a TB model of a square lattice

    # However, there is one problem...
    # tbtrans cannot handle too small problems.
    # For this square lattice it is too small, and we need it
    # to be wider for it to run (or one could increase the 
    # orbital range)

    # Here we correct the example to a wider system so it can be
    # run by tbtrans (it just needs to be [4 by 3]
    el  = SQ.repeat(4,axis=0)
    dev = el.tile(3,axis=1)
    TB_el = TBT_Model(el)
    for ia in xrange(el.na_u):
        idx_a = el.close_all(ia,dR=dR)
        TB_el[ia,idx_a[0]] = on
        TB_el[ia,idx_a[1]] = nn
    TB_dev = TBT_Model(dev)
    for ia in xrange(dev.na_u):
        idx_a = dev.close_all(ia,dR=dR)
        TB_dev[ia,idx_a[0]] = on
        TB_dev[ia,idx_a[1]] = nn
    # Now save the TB models to corresponding NetCDF-4 files
    TB_el.save('SQUARE_EL.nc',overwrite=True)
    with TBOutputFile('SQUARE_EL.tb') as fh:
        fh.write_geom(TB_el.geom)
        fh.write_model(TB_el)
    TB_dev.save('SQUARE_DEV.nc',overwrite=True)
    with TBOutputFile('SQUARE_DEV.tb') as fh:
        fh.write_geom(TB_dev.geom)
        fh.write_model(TB_dev)

    ############################
    #    To showcase the dH    #
    #    method introduced we  #
    #  do these small changes  #
    ############################
    print('Setting up dH model for SQUARE calculation cell...')

    # Create new TB model of sub-object TBT_dH
    TB_dH = TBT_dH(dev)
    # the dH method can be re-set several times
    TB_dH.reset()

    ########## LEVEL-1 ############
    #       REAL correction       #
    ###############################
    for ia in xrange(dev.na_u):
        TB_dH[ia,ia] = 0.1
    TB_dH.save('SQUARE_dH.nc',delete=True)

    # Initialize the k-point for level 2 and 4
    kpt = np.zeros((3,),np.float)

    ########## LEVEL-2 ############
    #      COMPLEX correction     #
    #    5 k-points               #
    ###############################
    TB_dH.reset(dtype=np.complex)
    for ik in xrange(5):
        kpt[0] = ik * 0.5 / 4
        if ik == 4: kpt[0] = (ik-1) * 0.5 / 4
        for ia in xrange(dev.na_u):
            TB_dH[ia,ia] = 0.1 + 1j*0.001 * ik
        TB_dH.save('SQUARE_dH.nc',kpt=kpt)

    ########## LEVEL-3 ############
    #        REAL correction      #
    #  100 energy-points          #
    ###############################
    TB_dH.reset()
    for iE in xrange(100):
        E = (iE-99.5)*0.025
        for ia in xrange(dev.na_u):
            TB_dH[ia,ia] = np.exp(-E**2) * 1e-1
        TB_dH.save('SQUARE_dH.nc',E=E)

    ########## LEVEL-4 ############
    #      COMPLEX correction     #
    #    5 k-points               #
    #  100 energy-points          #
    ###############################
    TB_dH.reset(dtype=np.complex)
    for ik in xrange(5):
        kpt[0] = ik * 0.5 / 4
        if ik == 4: kpt[0] = (ik-1) * 0.5 / 4
        for iE in xrange(100):
            E = (iE-49.5)*0.025
            for ia in xrange(dev.na_u):
                TB_dH[ia,ia] = 0.1 + 1j*np.exp(-E**2) * 1e-2
            TB_dH.save('SQUARE_dH.nc',E=E,kpt=kpt)

    # Done, the TB model for dH has now been saved with
    # several different methods.
    print('Done creating dH model permutations...')

if __name__ == '__main__':

    # This example code produces several TB NetCDF-4 files
    alat = 1.42
    sq3h  = 3.**.5 * 0.5
    GR_na_u = graphene_uc(alat).na_u

    # create the simple square hopping integral
    TB_square()

    #TB_save('ELEC_zz.nc',graphene_uc(alat))
    
    # We create all TB paramaters for a zz edge 
    # pristine graphene sample:
    for TB in ['A','B','C','D','E','F','G']:
        TB_save('ELEC_' + TB + '_zz.nc',
                graphene_uc(alat) , TB = _TB_graphene[TB], alat=alat)
        TB_save('DEV_'  + TB + '_zz.nc',
                graphene_uc(alat).tile(5,axis=1) , TB = _TB_graphene[TB],alat=alat)

    # For the below examples we use the D set and a 
    # lattice constant of 1.42
    TB   = _TB_graphene['D']
    on   = np.array([TB['U'] ,   1.  ])
    nn   = np.array([TB['n1'],TB['s1']])
    nnn  = np.array([TB['n2'],TB['s2']])
    nnnn = np.array([TB['n3'],TB['s3']])

    # Just for fun, create a graphene flake with a hole in it
    # This is essentially an anti-dot lattice with pristine electrodes
    Nx = 10 ; Ny = 30
    print('Repeating graphene UC to flake with hole containing '+str(Nx*Ny*GR_na_u)+' atoms...')
    HOLE = graphene_uc(alat).repeat(Nx,axis=0).tile(Ny,axis=1)
    HOLE.update(nsc=[1,1,0])
    # Remove a hole in the structure
    # We take some atom in the middle of the structure
    mid_atom = GR_na_u * (Nx * Ny) // 2
    # Get all indices for all super-cell atoms within 12 angstrom
    idx_a = HOLE.close_all(mid_atom,dR=12.)
    # Convert to unit-cell atomic indices
    idx_a %= HOLE.no_u
    # remove dublicates (in case the user makes a too large hole)
    idx_a = np.unique(idx_a)
    print('Removing '+str(len(idx_a))+' atoms...')
    HOLE = HOLE.remove(idx_a)
    HS = TBT_Model(HOLE, max_connection = 20)
    dR = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    idx_a,xa = HOLE.close_all(0,dR=dR,ret_coord=True)
    print('List of on-site coords for atom 1:',idx_a[0])
    print(xa[0])
    print('List of nn coords for atom 1:',idx_a[1])
    print(xa[1])
    print('Creating TB parameter Hamiltonian and overlap...')
    for ia in xrange(HOLE.na_u):
        idx_a = HOLE.close_all(ia,dR=dR)
        HS[ia,idx_a[0]] = on
        HS[ia,idx_a[1]] = nn
        HS[ia,idx_a[2]] = nnn
        HS[ia,idx_a[3]] = nnnn
    print('Converting to CSR sparsity format and saving NetCDF file...')
    HS.save('HOLE_D_zz.nc',Ef=TB['U'],overwrite=True)

    # Save an xyz file to let the user view the geometry
    HOLE.xyz('HOLE_zz.xyz',overwrite=True)

    print('Printing representation of HOLE:')
    print('>>>')
    print(HOLE)
    print('<<<')

    # Just for fun, create a HUGE graphene flake
    print('Starting time... '+str(datetime.datetime.now().time()))
    Nx = 40 ; Ny = 60
    print('Repeating graphene UC to huge flake containing '+str(Nx*Ny*GR_na_u)+' atoms...')
    HUGE = graphene_uc(alat).repeat(Nx,axis=0).tile(Ny,axis=1)
    HUGE.update(nsc=[1,1,0], dR = 2*alat)
    HUGE._iter = 10
    HS = TBT_Model(HUGE , max_connection = 20)
    dR = ( alat*0.5 , alat+0.1 , 2*sq3h*alat+0.1 , 2*alat+0.1 )
    print('Creating TB parameter Hamiltonian and overlap...')
    for ias, idxs in HUGE:
        for ia in ias:
            idx_a = HUGE.close_all(ia,dR=dR, idx = idxs)
            HS[ia,idx_a[0]] = on
            HS[ia,idx_a[1]] = nn
            HS[ia,idx_a[2]] = nnn
            HS[ia,idx_a[3]] = nnnn
    print('Converting to CSR sparsity format and saving NetCDF file...')
    HS.save('HUGE_D_zz.nc',Ef=TB['U'],overwrite=True)

    HUGE.xyz('HUGE_zz.xyz',overwrite=True)
    HUGE.XV('HUGE_zz.XV',overwrite=True)

    for f in ['HUGE_zz.XV','HUGE_D_zz.nc']:
        tmp = TBT_Geom.read(f)
        if np.all(np.abs(tmp.xa - HUGE.xa) < 1.e-6) and \
                np.all(np.abs(tmp.cell - HUGE.cell) < 1.e-6):
            print('Re-read '+f+' and ensured correctly read structure')
        else:
            print('Re-read '+f+' did not match present data')

    print('Ending time... '+str(datetime.datetime.now().time()))
